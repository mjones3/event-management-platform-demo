# Save this as: .github/workflows/scaffold-service.yml

name: Scaffold a new service

on:
  workflow_dispatch:
    inputs:
      service_name:
        required: true
        description: "The name of the new service"
        type: string
      description:
        required: false
        description: "Description of the service"
        type: string
        default: "A new microservice"
      openapi_spec_url:
        required: false
        description: "URL to OpenAPI specification (leave empty to auto-generate)"
        type: string
        default: ""
      port_run_id:
        required: false
        description: "Port run ID for logging"
        type: string

env:
  ORG_NAME: your-org-name # Replace with your actual GitHub org/username

permissions:
  contents: write # Allow the workflow to push changes
  pull-requests: write # Allow creating PRs if needed

jobs:
  scaffold-service:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Display inputs (for debugging)
        run: |
          echo "=== INPUTS ==="
          echo "Service Name: ${{ inputs.service_name }}"
          echo "Description: ${{ inputs.description }}"
          echo "OpenAPI Spec URL: ${{ inputs.openapi_spec_url }}"
          echo "Port Run ID: ${{ inputs.port_run_id }}"
          echo ""
          echo "=== GITHUB CONTEXT ==="
          echo "Triggered by: ${{ github.actor }}"
          echo "Repository: ${{ github.repository }}"
          echo "Event: ${{ github.event_name }}"
          echo ""
          echo "=== PORT RUN ID CHECK ==="
          if [ -n "${{ inputs.port_run_id }}" ]; then
            echo "âœ… Port run ID is present: ${{ inputs.port_run_id }}"
          else
            echo "âŒ Port run ID is missing"
          fi

      - name: Test Port connection (simple)
        if: ${{ inputs.port_run_id != '' }}
        continue-on-error: true
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: PATCH_RUN
          runId: ${{ inputs.port_run_id }}
          logMessage: "ðŸš€ Starting scaffolding of service: ${{ inputs.service_name }}"

      - name: Set up Java for OpenAPI generation
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"

      - name: Generate Spring Boot service from OpenAPI spec
        run: |
          set -e  # Exit on any error
          SERVICE_NAME="${{ inputs.service_name }}"

          echo "ðŸ”§ Starting service generation for: $SERVICE_NAME"

          # Validate service name
          if [[ ! "$SERVICE_NAME" =~ ^[a-z][a-z0-9-]*[a-z0-9]$ ]] || [[ ${#SERVICE_NAME} -lt 3 ]] || [[ ${#SERVICE_NAME} -gt 50 ]]; then
            echo "âŒ Invalid service name: $SERVICE_NAME"
            echo "Service name must be 3-50 characters, lowercase, kebab-case (e.g., my-service)"
            exit 1
          fi

          # Create directory for the new service
          mkdir -p "$SERVICE_NAME"
          cd "$SERVICE_NAME"

          # Download OpenAPI Generator CLI
          echo "ðŸ“¥ Downloading OpenAPI Generator..."
          if ! wget -q https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/7.2.0/openapi-generator-cli-7.2.0.jar -O openapi-generator-cli.jar; then
            echo "âŒ Failed to download OpenAPI Generator"
            exit 1
          fi

          # Verify download
          if [[ ! -f "openapi-generator-cli.jar" ]] || [[ ! -s "openapi-generator-cli.jar" ]]; then
            echo "âŒ OpenAPI Generator download failed or file is empty"
            exit 1
          fi

          echo "âœ… OpenAPI Generator downloaded successfully ($(ls -lh openapi-generator-cli.jar | awk '{print $5}'))"

          # Download your actual OpenAPI spec
          echo "ðŸ“‹ Fetching OpenAPI specification..."

          SPEC_FOUND=false

          # Check if user provided a custom OpenAPI spec URL
          if [ -n "${{ inputs.openapi_spec_url }}" ]; then
            echo "ðŸŒ Using provided OpenAPI spec URL: ${{ inputs.openapi_spec_url }}"
            if wget -q "${{ inputs.openapi_spec_url }}" -O api-spec.yaml && [[ -s api-spec.yaml ]]; then
              echo "âœ… Downloaded OpenAPI spec from provided URL"
              SPEC_FOUND=true
              
              # Validate it's actually an OpenAPI spec
              if grep -q "openapi\|swagger" api-spec.yaml; then
                echo "âœ… Valid OpenAPI/Swagger specification detected"
              else
                echo "âš ï¸  File downloaded but doesn't appear to be an OpenAPI spec"
                echo "First few lines:"
                head -5 api-spec.yaml
                echo "Continuing anyway..."
              fi
            else
              echo "âŒ Failed to download from provided URL: ${{ inputs.openapi_spec_url }}"
              echo "Will fall back to repository search or template generation"
            fi
          fi

          # Try multiple locations for the OpenAPI spec if no custom URL provided or custom URL failed
          if [[ "$SPEC_FOUND" == "false" ]]; then
            echo "ðŸ” Searching for OpenAPI spec in repository..."
            
            if wget -q https://raw.githubusercontent.com/mjones3/event-management-platform-demo/main/api-specs/user-service.yaml -O api-spec.yaml 2>/dev/null && [[ -s api-spec.yaml ]]; then
              echo "âœ… Downloaded OpenAPI spec from api-specs directory"
              SPEC_FOUND=true
            elif wget -q https://raw.githubusercontent.com/mjones3/event-management-platform-demo/main/openapi/user-service.yaml -O api-spec.yaml 2>/dev/null && [[ -s api-spec.yaml ]]; then
              echo "âœ… Downloaded OpenAPI spec from openapi directory"
              SPEC_FOUND=true
            elif wget -q https://raw.githubusercontent.com/mjones3/event-management-platform-demo/main/docs/api/user-service.yaml -O api-spec.yaml 2>/dev/null && [[ -s api-spec.yaml ]]; then
              echo "âœ… Downloaded OpenAPI spec from docs directory"
              SPEC_FOUND=true
            fi
          fi

          if [[ "$SPEC_FOUND" == "false" ]]; then
            echo "âš ï¸  Could not find existing OpenAPI spec, creating a template based on service name..."
            
            # Create a generic microservice spec based on the service name
            SERVICE_NAME_CAMEL="$(echo ${SERVICE_NAME} | sed 's/-\([a-z]\)/\U\1/g' | sed 's/^\([a-z]\)/\U\1/')"
            
            cat > api-spec.yaml << 'SPEC_EOF'
          openapi: 3.0.3
          info:
            title: SERVICE_NAME_CAMEL_PLACEHOLDER Service API
            description: SERVICE_DESCRIPTION_PLACEHOLDER
            version: 1.0.0
            contact:
              name: API Support
              email: support@eventplatform.com
          servers:
            - url: https://api.eventplatform.com/SERVICE_NAME_PLACEHOLDER/v1
              description: Production server
            - url: http://localhost:8080/api/v1
              description: Development server

          security:
            - BearerAuth: []

          paths:
            /health:
              get:
                summary: Health check endpoint
                description: Returns the health status of the service
                tags:
                  - Health
                security: []
                responses:
                  '200':
                    description: Service is healthy
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/HealthResponse'
            
            /SERVICE_NAME_PLACEHOLDER_PLURAL:
              get:
                summary: List SERVICE_NAME_PLACEHOLDER_PLURAL with pagination
                description: Retrieve a paginated list with optional filtering
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                parameters:
                  - name: page
                    in: query
                    description: Page number (0-based)
                    schema:
                      type: integer
                      minimum: 0
                      default: 0
                  - name: size
                    in: query
                    description: Page size
                    schema:
                      type: integer
                      minimum: 1
                      maximum: 100
                      default: 20
                  - name: search
                    in: query
                    description: Search term
                    schema:
                      type: string
                      minLength: 2
                responses:
                  '200':
                    description: Successfully retrieved items
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/PagedSERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  '400':
                    $ref: '#/components/responses/BadRequest'
                  '401':
                    $ref: '#/components/responses/Unauthorized'
              post:
                summary: Create a new item
                description: Create a new item in the system
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                requestBody:
                  required: true
                  content:
                    application/json:
                      schema:
                        $ref: '#/components/schemas/CreateSERVICE_NAME_CAMEL_PLACEHOLDERRequest'
                responses:
                  '201':
                    description: Item created successfully
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/SERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  '400':
                    $ref: '#/components/responses/BadRequest'
                  '401':
                    $ref: '#/components/responses/Unauthorized'
            
            /SERVICE_NAME_PLACEHOLDER_PLURAL/{id}:
              get:
                summary: Get item by ID
                description: Retrieve detailed information about a specific item
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                parameters:
                  - name: id
                    in: path
                    required: true
                    description: Item ID
                    schema:
                      type: string
                      format: uuid
                responses:
                  '200':
                    description: Item found
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/SERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  '404':
                    $ref: '#/components/responses/NotFound'
                  '401':
                    $ref: '#/components/responses/Unauthorized'
              put:
                summary: Update item
                description: Update item information (full update)
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                parameters:
                  - name: id
                    in: path
                    required: true
                    schema:
                      type: string
                      format: uuid
                requestBody:
                  required: true
                  content:
                    application/json:
                      schema:
                        $ref: '#/components/schemas/UpdateSERVICE_NAME_CAMEL_PLACEHOLDERRequest'
                responses:
                  '200':
                    description: Item updated successfully
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/SERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  '400':
                    $ref: '#/components/responses/BadRequest'
                  '404':
                    $ref: '#/components/responses/NotFound'
              delete:
                summary: Delete item
                description: Delete an item
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                parameters:
                  - name: id
                    in: path
                    required: true
                    schema:
                      type: string
                      format: uuid
                responses:
                  '204':
                    description: Item deleted successfully
                  '404':
                    $ref: '#/components/responses/NotFound'
                  '401':
                    $ref: '#/components/responses/Unauthorized'

          components:
            securitySchemes:
              BearerAuth:
                type: http
                scheme: bearer
                bearerFormat: JWT
            
            schemas:
              HealthResponse:
                type: object
                properties:
                  status:
                    type: string
                    example: "UP"
                  service:
                    type: string
                    example: "SERVICE_NAME_PLACEHOLDER"
                  timestamp:
                    type: string
                    format: date-time
                  version:
                    type: string
                    example: "1.0.0"
                required:
                  - status
                  - service
                  - timestamp
              
              SERVICE_NAME_CAMEL_PLACEHOLDERResponse:
                type: object
                properties:
                  id:
                    type: string
                    format: uuid
                    example: "550e8400-e29b-41d4-a716-446655440000"
                  name:
                    type: string
                    example: "Sample Item"
                  description:
                    type: string
                    example: "A sample item description"
                  status:
                    type: string
                    enum: [ACTIVE, INACTIVE, PENDING]
                    example: "ACTIVE"
                  createdAt:
                    type: string
                    format: date-time
                    example: "2024-01-15T10:30:00Z"
                  updatedAt:
                    type: string
                    format: date-time
                    example: "2024-01-20T14:22:00Z"
                required:
                  - id
                  - name
                  - status
                  - createdAt
              
              CreateSERVICE_NAME_CAMEL_PLACEHOLDERRequest:
                type: object
                properties:
                  name:
                    type: string
                    minLength: 1
                    maxLength: 100
                    example: "New Item"
                  description:
                    type: string
                    maxLength: 500
                    example: "Description of the new item"
                required:
                  - name
              
              UpdateSERVICE_NAME_CAMEL_PLACEHOLDERRequest:
                type: object
                properties:
                  name:
                    type: string
                    minLength: 1
                    maxLength: 100
                  description:
                    type: string
                    maxLength: 500
                  status:
                    type: string
                    enum: [ACTIVE, INACTIVE, PENDING]
              
              PagedSERVICE_NAME_CAMEL_PLACEHOLDERResponse:
                type: object
                properties:
                  content:
                    type: array
                    items:
                      $ref: '#/components/schemas/SERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  totalElements:
                    type: integer
                    format: int64
                    example: 150
                  totalPages:
                    type: integer
                    example: 8
                  size:
                    type: integer
                    example: 20
                  number:
                    type: integer
                    example: 0
                  first:
                    type: boolean
                    example: true
                  last:
                    type: boolean
                    example: false
                required:
                  - content
                  - totalElements
                  - totalPages
                  - size
                  - number
                  - first
                  - last
              
              ErrorResponse:
                type: object
                properties:
                  timestamp:
                    type: string
                    format: date-time
                    example: "2024-01-20T15:30:45Z"
                  status:
                    type: integer
                    example: 400
                  error:
                    type: string
                    example: "Bad Request"
                  message:
                    type: string
                    example: "Validation failed"
                  path:
                    type: string
                    example: "/api/v1/items"
                required:
                  - timestamp
                  - status
                  - error
                  - message
                  - path
            
            responses:
              BadRequest:
                description: Bad request - validation errors
                content:
                  application/json:
                    schema:
                      $ref: '#/components/schemas/ErrorResponse'
              
              Unauthorized:
                description: Authentication required
                content:
                  application/json:
                    schema:
                      $ref: '#/components/schemas/ErrorResponse'
              
              NotFound:
                description: Resource not found
                content:
                  application/json:
                    schema:
                      $ref: '#/components/schemas/ErrorResponse'

          tags:
            - name: SERVICE_NAME_CAMEL_PLACEHOLDER
              description: Item management operations
            - name: Health
              description: Service health endpoints
          SPEC_EOF

            # Replace placeholders in the spec
            sed -i "s/SERVICE_NAME_PLACEHOLDER/${SERVICE_NAME}/g" api-spec.yaml
            sed -i "s/SERVICE_NAME_CAMEL_PLACEHOLDER/${SERVICE_NAME_CAMEL}/g" api-spec.yaml
            sed -i "s/SERVICE_DESCRIPTION_PLACEHOLDER/${{ inputs.description }}/g" api-spec.yaml
            sed -i "s/SERVICE_NAME_PLACEHOLDER_PLURAL/${SERVICE_NAME}s/g" api-spec.yaml
            
            echo "âœ… Generated template OpenAPI spec"
          fi

          # Validate the OpenAPI spec
          echo "ðŸ“„ Validating OpenAPI specification..."
          if [[ ! -s api-spec.yaml ]]; then
            echo "âŒ OpenAPI spec file is empty"
            exit 1
          fi

          # Show first few lines of the spec
          echo "ðŸ“„ OpenAPI specification preview:"
          head -15 api-spec.yaml
          echo "..."

          # Test if Java is available and working
          echo "â˜• Testing Java installation..."
          if ! java -version; then
            echo "âŒ Java is not available or not working"
            exit 1
          fi

          # Test if the JAR file is executable
          echo "ðŸ§ª Testing OpenAPI Generator..."
          if ! java -jar openapi-generator-cli.jar version; then
            echo "âŒ OpenAPI Generator is not working"
            exit 1
          fi

          # Generate Spring Boot application
          echo "ðŸ”§ Generating Spring Boot service..."

          PACKAGE_NAME="com.eventplatform.$(echo $SERVICE_NAME | tr '-' '.')"

          java -jar openapi-generator-cli.jar generate \
            -i api-spec.yaml \
            -g spring \
            -o . \
            --additional-properties=\
          packageName=${PACKAGE_NAME},\
          apiPackage=${PACKAGE_NAME}.controller,\
          modelPackage=${PACKAGE_NAME}.model,\
          configPackage=${PACKAGE_NAME}.config,\
          basePackage=${PACKAGE_NAME},\
          groupId=com.eventplatform,\
          artifactId=$SERVICE_NAME,\
          artifactVersion=1.0.0,\
          java8=false,\
          dateLibrary=java8,\
          interfaceOnly=false,\
          skipDefaultInterface=false,\
          useTags=true,\
          singleContentTypes=true,\
          performBeanValidation=true,\
          useBeanValidation=true,\
          library=spring-boot,\
          documentationProvider=springdoc,\
          openApiNullable=false,\
          hideGenerationTimestamp=true

          # Check if generation was successful
          if [[ ! -f "pom.xml" ]]; then
            echo "âŒ Spring Boot generation failed - no pom.xml found"
            ls -la
            exit 1
          fi

          echo "âœ… Spring Boot service generated successfully!"
          echo "ðŸ“ Generated files:"
          find . -name "*.java" -type f | head -10
          echo "..."

      - name: Enhance generated service with microservice features
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Check if we have a pom.xml and enhance it
          if [[ -f "pom.xml" ]]; then
            echo "ðŸ“¦ Enhancing pom.xml with additional dependencies..."
            
            # Create a backup
            cp pom.xml pom.xml.backup
            
            # Function to check if dependency exists
            check_dependency() {
              local groupId=$1
              local artifactId=$2
              grep -q "<groupId>$groupId</groupId>" pom.xml && \
              grep -A1 "<groupId>$groupId</groupId>" pom.xml | grep -q "<artifactId>$artifactId</artifactId>"
            }
            
            # Build list of dependencies to add (only if they don't exist)
            DEPS_TO_ADD=""
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-data-jpa"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-data-jpa</artifactId>
          		</dependency>"
            else
              echo "spring-boot-starter-data-jpa already exists"
            fi
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-actuator"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-actuator</artifactId>
          		</dependency>"
            else
              echo "spring-boot-starter-actuator already exists"
            fi
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-validation"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-validation</artifactId>
          		</dependency>"
            else
              echo "spring-boot-starter-validation already exists"
            fi
            
            if ! check_dependency "org.postgresql" "postgresql"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.postgresql</groupId>
          			<artifactId>postgresql</artifactId>
          			<scope>runtime</scope>
          		</dependency>"
            else
              echo "postgresql already exists"
            fi
            
            if ! check_dependency "io.micrometer" "micrometer-registry-prometheus"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>io.micrometer</groupId>
          			<artifactId>micrometer-registry-prometheus</artifactId>
          		</dependency>"
            else
              echo "micrometer-registry-prometheus already exists"
            fi
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-test"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-test</artifactId>
          			<scope>test</scope>
          		</dependency>"
            else
              echo "spring-boot-starter-test already exists"
            fi
            
            if ! check_dependency "org.flywaydb" "flyway-core"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.flywaydb</groupId>
          			<artifactId>flyway-core</artifactId>
          		</dependency>"
            else
              echo "flyway-core already exists"
            fi
            
            if ! check_dependency "org.flywaydb" "flyway-database-postgresql"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.flywaydb</groupId>
          			<artifactId>flyway-database-postgresql</artifactId>
          		</dependency>"
            else
              echo "flyway-database-postgresql already exists"
            fi
            
            # Add dependencies if any were collected
            if [[ -n "$DEPS_TO_ADD" ]]; then
              echo "Adding new dependencies..."
              # Create temp file with additional dependencies
              cat > additional_deps.txt << EOF
          		<!-- Additional Spring Boot Dependencies -->$DEPS_TO_ADD
          EOF
              
              # Insert before </dependencies>
              sed -i '/<\/dependencies>/e cat additional_deps.txt' pom.xml
              rm additional_deps.txt
            else
              echo "All required dependencies already exist"
            fi
            
            # Check if Spring Boot Maven plugin already exists, if not add it
            if ! grep -q "spring-boot-maven-plugin" pom.xml; then
              echo "Adding Spring Boot Maven plugin..."
              # Only add build section if it doesn't exist
              if ! grep -q "<build>" pom.xml; then
                sed -i '/<\/project>/i\
          	<build>\
          		<plugins>\
          			<plugin>\
          				<groupId>org.springframework.boot</groupId>\
          				<artifactId>spring-boot-maven-plugin</artifactId>\
          				<configuration>\
          					<excludes>\
          						<exclude>\
          							<groupId>org.projectlombok</groupId>\
          							<artifactId>lombok</artifactId>\
          						</exclude>\
          					</excludes>\
          				</configuration>\
          			</plugin>\
          		</plugins>\
          	</build>' pom.xml
              else
                # Build section exists, just add the plugin to existing plugins section
                if grep -q "<plugins>" pom.xml; then
                  sed -i '/<\/plugins>/i\
          			<plugin>\
          				<groupId>org.springframework.boot</groupId>\
          				<artifactId>spring-boot-maven-plugin</artifactId>\
          				<configuration>\
          					<excludes>\
          						<exclude>\
          							<groupId>org.projectlombok</groupId>\
          							<artifactId>lombok</artifactId>\
          						</exclude>\
          					</excludes>\
          				</configuration>\
          			</plugin>' pom.xml
                else
                  # Build exists but no plugins section
                  sed -i '/<\/build>/i\
          		<plugins>\
          			<plugin>\
          				<groupId>org.springframework.boot</groupId>\
          				<artifactId>spring-boot-maven-plugin</artifactId>\
          				<configuration>\
          					<excludes>\
          						<exclude>\
          							<groupId>org.projectlombok</groupId>\
          							<artifactId>lombok</artifactId>\
          						</exclude>\
          					</excludes>\
          				</configuration>\
          			</plugin>\
          		</plugins>' pom.xml
                fi
              fi
            else
              echo "Spring Boot Maven plugin already exists, skipping..."
            fi
            
            echo "âœ… Enhanced pom.xml successfully"
            echo "ðŸ“„ Final pom.xml validation:"
            if mvn help:effective-pom -q > /dev/null 2>&1; then
              echo "âœ… pom.xml is valid"
            else
              echo "âŒ pom.xml has issues, showing structure:"
              grep -n "groupId\|artifactId\|version" pom.xml | head -30
            fi
          else
            echo "âŒ No pom.xml found to enhance"
          fi

      - name: Create main application class
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Find the main application class and ensure it exists and is correct
          PACKAGE_DIR="src/main/java/com/eventplatform/$(echo $SERVICE_NAME | tr '-' '/')"
          MAIN_CLASS_NAME="$(echo $SERVICE_NAME | sed 's/-//g' | sed 's/\b\w/\U&/g')Application"
          
          echo "ðŸ“ Creating/updating main application class: $MAIN_CLASS_NAME"
          
          # Create the main application class
          mkdir -p "$PACKAGE_DIR"
          cat > "$PACKAGE_DIR/${MAIN_CLASS_NAME}.java" << EOF
          package com.eventplatform.$(echo $SERVICE_NAME | tr '-' '.');
          
          import org.springframework.boot.SpringApplication;
          import org.springframework.boot.autoconfigure.SpringBootApplication;
          import org.springframework.web.bind.annotation.GetMapping;
          import org.springframework.web.bind.annotation.RestController;
          import java.util.Map;
          import java.util.HashMap;
          
          @SpringBootApplication
          public class ${MAIN_CLASS_NAME} {
              public static void main(String[] args) {
                  SpringApplication.run(${MAIN_CLASS_NAME}.class, args);
              }
          }
          
          @RestController
          class HealthController {
              
              @GetMapping("/")
              public Map<String, Object> root() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("service", "$SERVICE_NAME");
                  response.put("status", "UP");
                  response.put("message", "Welcome to $SERVICE_NAME API");
                  response.put("documentation", "/swagger-ui.html");
                  response.put("health", "/actuator/health");
                  return response;
              }
              
              @GetMapping("/api/v1/health")
              public Map<String, Object> health() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("status", "UP");
                  response.put("service", "$SERVICE_NAME");
                  response.put("timestamp", java.time.Instant.now().toString());
                  response.put("version", "1.0.0");
                  return response;
              }
          }
          EOF

      - name: Create application configuration files
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create application.yml with proper configuration
          mkdir -p src/main/resources
          cat > src/main/resources/application.yml << 'EOF'
          server:
            port: ${PORT:8080}
          
          spring:
            application:
              name: SERVICE_NAME_PLACEHOLDER
            datasource:
              url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:SERVICE_NAME_DB_PLACEHOLDER}
              username: ${DB_USERNAME:postgres}
              password: ${DB_PASSWORD:password}
            jpa:
              hibernate:
                ddl-auto: ${JPA_DDL_AUTO:create-drop}
              show-sql: ${JPA_SHOW_SQL:false}
              properties:
                hibernate:
                  format_sql: true
                  dialect: org.hibernate.dialect.PostgreSQLDialect
            
          management:
            endpoints:
              web:
                exposure:
                  include: health,info,metrics,prometheus
            endpoint:
              health:
                show-details: always
            metrics:
              export:
                prometheus:
                  enabled: true
          
          logging:
            level:
              com.eventplatform: ${LOG_LEVEL:INFO}
              org.springframework.web: ${WEB_LOG_LEVEL:WARN}
              org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}
          
          springdoc:
            api-docs:
              path: /api-docs
            swagger-ui:
              path: /swagger-ui.html
              operations-sorter: method
          EOF
          
          # Replace placeholders in application.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" src/main/resources/application.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" src/main/resources/application.yml
          
          # Create application.properties as fallback
          cat > src/main/resources/application.properties << EOF
          # Application Configuration
          spring.application.name=$SERVICE_NAME
          server.port=8080
          
          # Database Configuration
          spring.datasource.url=jdbc:postgresql://localhost:5432/${SERVICE_NAME//-/_}_db
          spring.datasource.username=postgres
          spring.datasource.password=password
          spring.jpa.hibernate.ddl-auto=create-drop
          spring.jpa.show-sql=false
          
          # Actuator Configuration
          management.endpoints.web.exposure.include=health,info,metrics
          management.endpoint.health.show-details=always
          
          # Logging Configuration
          logging.level.com.eventplatform=INFO
          EOF

      - name: Build Spring Boot application
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          echo "ðŸ”§ Building the Spring Boot application..."
          
          # Build the application
          if command -v mvn &> /dev/null; then
            echo "ðŸ“¦ Building with Maven..."
            mvn clean package -DskipTests -q
            
            # Check if JAR was created
            if [[ -f target/*.jar ]]; then
              echo "âœ… JAR built successfully:"
              ls -la target/*.jar
            else
              echo "âŒ JAR build failed, creating minimal JAR structure..."
              mkdir -p target
              # We'll handle this in the Docker build
            fi
          else
            echo "âš ï¸  Maven not available, will build in Docker"
          fi

      - name: Create Docker configuration
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create an enhanced Dockerfile with multi-stage build
          cat > Dockerfile << 'EOF'
          # Multi-stage build for Spring Boot application
          FROM maven:3.9-openjdk-17-slim AS builder
          
          WORKDIR /app
          
          # Copy pom.xml first for better caching
          COPY pom.xml .
          
          # Download dependencies
          RUN mvn dependency:go-offline -B
          
          # Copy source code
          COPY src ./src
          
          # Build the application
          RUN mvn clean package -DskipTests -B
          
          # Runtime stage
          FROM openjdk:17-jdk-slim
          
          WORKDIR /app
          
          # Copy the JAR from builder stage
          COPY --from=builder /app/target/*.jar app.jar
          
          # Create non-root user
          RUN addgroup --system spring && adduser --system spring --ingroup spring
          USER spring:spring
          
          # Expose port
          EXPOSE 8080
          
          # Health check
          HEALTHCHECK --interval=30s --timeout=3s --start-period=30s --retries=3 \
              CMD curl -f http://localhost:8080/actuator/health || exit 1
          
          # Run the application
          ENTRYPOINT ["java", "-jar", "app.jar"]
          EOF

      - name: Create Docker Compose configuration
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create docker-compose.yml with working setup
          cat > docker-compose.yml << 'EOF'
          version: '3.8'
          services:
            SERVICE_NAME_PLACEHOLDER:
              build: .
              ports:
                - "${SERVICE_PORT:-8080}:8080"
              environment:
                - SPRING_PROFILES_ACTIVE=docker
                - DB_HOST=postgres
                - DB_USERNAME=postgres
                - DB_PASSWORD=password
                - DB_NAME=SERVICE_NAME_DB_PLACEHOLDER
              depends_on:
                postgres:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
            
            postgres:
              image: postgres:15-alpine
              environment:
                - POSTGRES_DB=SERVICE_NAME_DB_PLACEHOLDER
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=password
              ports:
                - "${DB_PORT:-5432}:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5
          
          volumes:
            postgres_data:
          EOF
          
          # Replace placeholders in docker-compose.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" docker-compose.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" docker-compose.yml

      - name: Create utility scripts
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create a startup script
          cat > start.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "ðŸš€ Starting SERVICE_NAME_PLACEHOLDER..."
          
          # Check if Docker is available
          if command -v docker &> /dev/null; then
              echo "ðŸ³ Starting with Docker Compose..."
              docker-compose up --build -d
              
              echo "â³ Waiting for services to be healthy..."
              sleep 30
              
              echo "ðŸ” Checking service health..."
              curl -f http://localhost:8080/actuator/health || echo "âŒ Health check failed"
              
              echo "ðŸ“– API Documentation: http://localhost:8080/swagger-ui.html"
              echo "â¤ï¸  Health Endpoint: http://localhost:8080/actuator/health"
              echo "ðŸ  Service Root: http://localhost:8080/"
          else
              echo "ðŸ“¦ Building with Maven..."
              mvn clean package -DskipTests
              
              echo "â˜• Starting Spring Boot application..."
              java -jar target/*.jar
          fi
          EOF
          
          # Replace placeholder in start.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" start.sh
          chmod +x start.sh
          
          # Create a test script
          cat > test-service.sh << 'EOF'
          #!/bin/bash
          set -e
          
          SERVICE_URL="http://localhost:8080"
          
          echo "ðŸ§ª Testing SERVICE_NAME_PLACEHOLDER..."
          
          # Test root endpoint
          echo "Testing root endpoint..."
          curl -s "$SERVICE_URL/" | jq . || echo "Root endpoint test failed"
          
          # Test health endpoint
          echo "Testing health endpoint..."
          curl -s "$SERVICE_URL/actuator/health" | jq . || echo "Health endpoint test failed"
          
          # Test API health endpoint
          echo "Testing API health endpoint..."
          curl -s "$SERVICE_URL/api/v1/health" | jq . || echo "API health endpoint test failed"
          
          echo "âœ… Service tests completed!"
          EOF
          
          # Replace placeholder in test-service.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" test-service.sh
          chmod +x test-service.sh

      - name: Setup Python for database schema generation
        run: |
          # Install Python3 and PyYAML if not available
          if ! command -v python3 &> /dev/null; then
            echo "Installing Python3..."
            sudo apt-get update && sudo apt-get install -y python3 python3-pip
          fi
          
          if ! python3 -c "import yaml" 2>/dev/null; then
            echo "Installing PyYAML..."
            pip3 install PyYAML
          fi

      - name: Create database schema generation script
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create database directory
          mkdir -p src/main/resources/db/migration
          mkdir -p database/scripts
          
          # Create the Python script for schema generation
          cat > generate_schema.py << 'EOF'
          import yaml
          import json
          import re
          import os
          from datetime import datetime
          
          def openapi_type_to_postgres(openapi_type, format_type=None, enum_values=None):
              """Convert OpenAPI types to PostgreSQL types"""
              type_mapping = {
                  'string': {
                      'date': 'DATE',
                      'date-time': 'TIMESTAMP WITH TIME ZONE',
                      'uuid': 'UUID',
                      'uri': 'TEXT',
                      'url': 'TEXT',
                      'email': 'VARCHAR(255)',
                      'password': 'VARCHAR(255)',
                      None: 'TEXT'
                  },
                  'integer': {
                      'int32': 'INTEGER',
                      'int64': 'BIGINT',
                      None: 'INTEGER'
                  },
                  'number': {
                      'float': 'REAL',
                      'double': 'DOUBLE PRECISION',
                      'decimal': 'DECIMAL(10,2)',
                      None: 'DECIMAL(10,2)'
                  },
                  'boolean': {
                      None: 'BOOLEAN'
                  },
                  'array': {
                      None: 'JSONB'
                  },
                  'object': {
                      None: 'JSONB'
                  }
              }
              
              if enum_values:
                  return f"VARCHAR(50) CHECK (VALUE IN ({', '.join([f\"'{v}'\" for v in enum_values])}))"
              
              return type_mapping.get(openapi_type, {}).get(format_type, type_mapping.get(openapi_type, {}).get(None, 'TEXT'))
          
          def snake_case(name):
              """Convert camelCase or PascalCase to snake_case"""
              s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
              return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
          
          def generate_table_name(schema_name):
              """Generate table name from schema name"""
              table_name = schema_name
              for suffix in ['Response', 'Request', 'DTO', 'Entity']:
                  if table_name.endswith(suffix):
                      table_name = table_name[:-len(suffix)]
                      break
              return snake_case(table_name) + 's'
          
          try:
              # Load the OpenAPI spec
              with open('api-spec.yaml', 'r') as f:
                  spec = yaml.safe_load(f)
              
              schemas = spec.get('components', {}).get('schemas', {})
              
              # Generate SQL
              sql_statements = []
              sql_statements.append("-- Generated PostgreSQL schema from OpenAPI specification")
              sql_statements.append(f"-- Generated on: {datetime.now().isoformat()}")
              sql_statements.append("")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"pg_trgm\";")
              sql_statements.append("")
              
              # Generate tables for schemas
              for schema_name, schema_def in schemas.items():
                  if schema_def.get('type') == 'object' and 'properties' in schema_def:
                      if any(suffix in schema_name for suffix in ['Request', 'Response', 'Error', 'Paged']):
                          continue
                      
                      table_name = generate_table_name(schema_name)
                      sql_statements.append(f"CREATE TABLE IF NOT EXISTS {table_name} (")
                      sql_statements.append("    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),")
                      sql_statements.append("    name VARCHAR(255) NOT NULL,")
                      sql_statements.append("    description TEXT,")
                      sql_statements.append("    status VARCHAR(50) DEFAULT 'ACTIVE',")
                      sql_statements.append("    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    version BIGINT DEFAULT 1")
                      sql_statements.append(");")
                      sql_statements.append("")
              
              # Write files
              schema_content = '\n'.join(sql_statements)
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              print("âœ… Generated PostgreSQL schema successfully!")
              
          except Exception as e:
              print(f"âš ï¸  Could not generate database schema: {e}")
              # Create basic schema as fallback
              basic_schema = f"""-- Basic schema
          CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
          
          CREATE TABLE IF NOT EXISTS entities (
              id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
              name VARCHAR(255) NOT NULL,
              description TEXT,
              status VARCHAR(50) DEFAULT 'ACTIVE',
              created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              version BIGINT DEFAULT 1
          );"""
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              print("âœ… Generated basic database schema as fallback")
          EOF

      - name: Generate database schema
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          echo "ðŸ—„ï¸  Generating PostgreSQL database schema..."
          python3 generate_schema.py

      - name: Create database initialization scripts
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create database initialization script
          cat > database/scripts/init-database.sh << 'EOF'
          #!/bin/bash
          set -e
          
          DB_NAME=${1:-"SERVICE_NAME_DB_PLACEHOLDER"}
          DB_USER=${2:-"postgres"}
          DB_PASSWORD=${3:-"password"}
          DB_HOST=${4:-"localhost"}
          DB_PORT=${5:-"5432"}
          
          echo "ðŸ—„ï¸  Initializing database: $DB_NAME"
          
          # Wait for PostgreSQL to be ready
          until PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c '\q'; do
            echo "â³ Waiting for PostgreSQL..."
            sleep 2
          done
          
          # Create database if it doesn't exist
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c "CREATE DATABASE \"$DB_NAME\""
          
          # Run schema script
          echo "ðŸ“‹ Running schema migrations..."
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f 001_initial_schema.sql
          
          echo "âœ… Database initialization completed!"
          EOF
          
          # Replace placeholder in init script
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" database/scripts/init-database.sh
          chmod +x database/scripts/init-database.sh
          
          # Create sample data script
          cat > database/scripts/002_sample_data.sql << EOF
          -- Sample data for $SERVICE_NAME
          -- Generated on: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          -- Insert sample data here
          -- Example:
          -- INSERT INTO entities (name, description, status) VALUES 
          --   ('Sample Entity 1', 'This is a sample entity for testing', 'ACTIVE'),
          --   ('Sample Entity 2', 'Another sample entity', 'ACTIVE');
          
          -- You can uncomment and modify the above lines to add sample data
          EOF

      - name: Create database documentation
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create database documentation
          cat > database/README.md << EOF
          # Database Schema for $SERVICE_NAME
          
          This directory contains the PostgreSQL database schema and related scripts for the $SERVICE_NAME.
          
          ## ðŸ“ Structure
          
          - \`scripts/\` - Database scripts and migrations
            - \`001_initial_schema.sql\` - Initial database schema
            - \`002_sample_data.sql\` - Sample data for development
            - \`init-database.sh\` - Database initialization script
          
          ## ðŸš€ Quick Start
          
          ### Using Docker Compose (Recommended)
          The database is automatically set up when you run:
          \`\`\`bash
          docker-compose up -d
          \`\`\`
          
          ### Manual Setup
          1. **Start PostgreSQL:**
             \`\`\`bash
             docker run -d --name postgres \\
               -e POSTGRES_DB=${SERVICE_NAME//-/_}_db \\
               -e POSTGRES_USER=postgres \\
               -e POSTGRES_PASSWORD=password \\
               -p 5432:5432 postgres:15
             \`\`\`
          
          2. **Initialize the database:**
             \`\`\`bash
             cd database/scripts
             ./init-database.sh
             \`\`\`
          
          3. **Connect to the database:**
             \`\`\`bash
             psql -h localhost -U postgres -d ${SERVICE_NAME//-/_}_db
             \`\`\`
          
          ## ðŸ“‹ Connection Details
          
          - **Host:** localhost
          - **Port:** 5432
          - **Database:** ${SERVICE_NAME//-/_}_db
          - **Username:** postgres
          - **Password:** password
          EOF
          
          echo "âœ… Generated complete PostgreSQL database setup!"
          echo "ðŸ“ Database files created:"
          find database -type f | head -10
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create database documentation
          cat > database/README.md << EOF
          # Database Schema for $SERVICE_NAME

          This directory contains the PostgreSQL database schema and related scripts for the $SERVICE_NAME.

          ## ðŸ“ Structure

          - \`scripts/\` - Database scripts and migrations
            - \`001_initial_schema.sql\` - Initial database schema
            - \`002_sample_data.sql\` - Sample data for development
            - \`init-database.sh\` - Database initialization script

          ## ðŸš€ Quick Start

          ### Using Docker Compose (Recommended)
          The database is automatically set up when you run:
          \`\`\`bash
          docker-compose up -d
          \`\`\`

          ### Manual Setup
          1. **Start PostgreSQL:**
             \`\`\`bash
             docker run -d --name postgres \\
               -e POSTGRES_DB=${SERVICE_NAME//-/_}_db \\
               -e POSTGRES_USER=postgres \\
               -e POSTGRES_PASSWORD=password \\
               -p 5432:5432 postgres:15
             \`\`\`

          2. **Initialize the database:**
             \`\`\`bash
             cd database/scripts
             ./init-database.sh
             \`\`\`

          3. **Connect to the database:**
             \`\`\`bash
             psql -h localhost -U postgres -d ${SERVICE_NAME//-/_}_db
             \`\`\`

          ## ðŸ“‹ Connection Details

          - **Host:** localhost
          - **Port:** 5432
          - **Database:** ${SERVICE_NAME//-/_}_db
          - **Username:** postgres
          - **Password:** password
          EOF

          echo "âœ… Generated complete PostgreSQL database setup!"
          echo "ðŸ“ Database files created:"
          find database -type f | head -10
      - name: Create main application class
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Find the main application class and ensure it exists and is correct
          PACKAGE_DIR="src/main/java/com/eventplatform/$(echo $SERVICE_NAME | tr '-' '/')"
          MAIN_CLASS_NAME="$(echo $SERVICE_NAME | sed 's/-//g' | sed 's/\b\w/\U&/g')Application"

          echo "ðŸ“ Creating/updating main application class: $MAIN_CLASS_NAME"

          # Create the main application class
          mkdir -p "$PACKAGE_DIR"
          cat > "$PACKAGE_DIR/${MAIN_CLASS_NAME}.java" << EOF
          package com.eventplatform.$(echo $SERVICE_NAME | tr '-' '.');

          import org.springframework.boot.SpringApplication;
          import org.springframework.boot.autoconfigure.SpringBootApplication;
          import org.springframework.web.bind.annotation.GetMapping;
          import org.springframework.web.bind.annotation.RestController;
          import java.util.Map;
          import java.util.HashMap;

          @SpringBootApplication
          public class ${MAIN_CLASS_NAME} {
              public static void main(String[] args) {
                  SpringApplication.run(${MAIN_CLASS_NAME}.class, args);
              }
          }

          @RestController
          class HealthController {
              
              @GetMapping("/")
              public Map<String, Object> root() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("service", "$SERVICE_NAME");
                  response.put("status", "UP");
                  response.put("message", "Welcome to $SERVICE_NAME API");
                  response.put("documentation", "/swagger-ui.html");
                  response.put("health", "/actuator/health");
                  return response;
              }
              
              @GetMapping("/api/v1/health")
              public Map<String, Object> health() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("status", "UP");
                  response.put("service", "$SERVICE_NAME");
                  response.put("timestamp", java.time.Instant.now().toString());
                  response.put("version", "1.0.0");
                  return response;
              }
          }
          EOF

      - name: Create application configuration files
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create application.yml with proper configuration
          mkdir -p src/main/resources
          cat > src/main/resources/application.yml << 'EOF'
          server:
            port: ${PORT:8080}

          spring:
            application:
              name: SERVICE_NAME_PLACEHOLDER
            datasource:
              url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:SERVICE_NAME_DB_PLACEHOLDER}
              username: ${DB_USERNAME:postgres}
              password: ${DB_PASSWORD:password}
            jpa:
              hibernate:
                ddl-auto: ${JPA_DDL_AUTO:create-drop}
              show-sql: ${JPA_SHOW_SQL:false}
              properties:
                hibernate:
                  format_sql: true
                  dialect: org.hibernate.dialect.PostgreSQLDialect
            
          management:
            endpoints:
              web:
                exposure:
                  include: health,info,metrics,prometheus
            endpoint:
              health:
                show-details: always
            metrics:
              export:
                prometheus:
                  enabled: true

          logging:
            level:
              com.eventplatform: ${LOG_LEVEL:INFO}
              org.springframework.web: ${WEB_LOG_LEVEL:WARN}
              org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}

          springdoc:
            api-docs:
              path: /api-docs
            swagger-ui:
              path: /swagger-ui.html
              operations-sorter: method
          EOF

          # Replace placeholders in application.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" src/main/resources/application.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" src/main/resources/application.yml

          # Create application.properties as fallback
          cat > src/main/resources/application.properties << EOF
          # Application Configuration
          spring.application.name=$SERVICE_NAME
          server.port=8080

          # Database Configuration
          spring.datasource.url=jdbc:postgresql://localhost:5432/${SERVICE_NAME//-/_}_db
          spring.datasource.username=postgres
          spring.datasource.password=password
          spring.jpa.hibernate.ddl-auto=create-drop
          spring.jpa.show-sql=false

          # Actuator Configuration
          management.endpoints.web.exposure.include=health,info,metrics
          management.endpoint.health.show-details=always

          # Logging Configuration
          logging.level.com.eventplatform=INFO
          EOF

      - name: Build Spring Boot application
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          echo "ðŸ”§ Building the Spring Boot application..."

          # Build the application
          if command -v mvn &> /dev/null; then
            echo "ðŸ“¦ Building with Maven..."
            mvn clean package -DskipTests -q
            
            # Check if JAR was created
            if [[ -f target/*.jar ]]; then
              echo "âœ… JAR built successfully:"
              ls -la target/*.jar
            else
              echo "âŒ JAR build failed, creating minimal JAR structure..."
              mkdir -p target
              # We'll handle this in the Docker build
            fi
          else
            echo "âš ï¸  Maven not available, will build in Docker"
          fi

      - name: Create Docker configuration
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create an enhanced Dockerfile with multi-stage build
          cat > Dockerfile << 'EOF'
          # Multi-stage build for Spring Boot application
          FROM maven:3.9-openjdk-17-slim AS builder

          WORKDIR /app

          # Copy pom.xml first for better caching
          COPY pom.xml .

          # Download dependencies
          RUN mvn dependency:go-offline -B

          # Copy source code
          COPY src ./src

          # Build the application
          RUN mvn clean package -DskipTests -B

          # Runtime stage
          FROM openjdk:17-jdk-slim

          WORKDIR /app

          # Copy the JAR from builder stage
          COPY --from=builder /app/target/*.jar app.jar

          # Create non-root user
          RUN addgroup --system spring && adduser --system spring --ingroup spring
          USER spring:spring

          # Expose port
          EXPOSE 8080

          # Health check
          HEALTHCHECK --interval=30s --timeout=3s --start-period=30s --retries=3 \
              CMD curl -f http://localhost:8080/actuator/health || exit 1

          # Run the application
          ENTRYPOINT ["java", "-jar", "app.jar"]
          EOF

      - name: Create Docker Compose configuration
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create docker-compose.yml with working setup
          cat > docker-compose.yml << 'EOF'
          version: '3.8'
          services:
            SERVICE_NAME_PLACEHOLDER:
              build: .
              ports:
                - "${SERVICE_PORT:-8080}:8080"
              environment:
                - SPRING_PROFILES_ACTIVE=docker
                - DB_HOST=postgres
                - DB_USERNAME=postgres
                - DB_PASSWORD=password
                - DB_NAME=SERVICE_NAME_DB_PLACEHOLDER
              depends_on:
                postgres:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
            
            postgres:
              image: postgres:15-alpine
              environment:
                - POSTGRES_DB=SERVICE_NAME_DB_PLACEHOLDER
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=password
              ports:
                - "${DB_PORT:-5432}:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5

          volumes:
            postgres_data:
          EOF

          # Replace placeholders in docker-compose.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" docker-compose.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" docker-compose.yml

      - name: Create utility scripts
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create a startup script
          cat > start.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "ðŸš€ Starting SERVICE_NAME_PLACEHOLDER..."

          # Check if Docker is available
          if command -v docker &> /dev/null; then
              echo "ðŸ³ Starting with Docker Compose..."
              docker-compose up --build -d
              
              echo "â³ Waiting for services to be healthy..."
              sleep 30
              
              echo "ðŸ” Checking service health..."
              curl -f http://localhost:8080/actuator/health || echo "âŒ Health check failed"
              
              echo "ðŸ“– API Documentation: http://localhost:8080/swagger-ui.html"
              echo "â¤ï¸  Health Endpoint: http://localhost:8080/actuator/health"
              echo "ðŸ  Service Root: http://localhost:8080/"
          else
              echo "ðŸ“¦ Building with Maven..."
              mvn clean package -DskipTests
              
              echo "â˜• Starting Spring Boot application..."
              java -jar target/*.jar
          fi
          EOF

          # Replace placeholder in start.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" start.sh
          chmod +x start.sh

          # Create a test script
          cat > test-service.sh << 'EOF'
          #!/bin/bash
          set -e

          SERVICE_URL="http://localhost:8080"

          echo "ðŸ§ª Testing SERVICE_NAME_PLACEHOLDER..."

          # Test root endpoint
          echo "Testing root endpoint..."
          curl -s "$SERVICE_URL/" | jq . || echo "Root endpoint test failed"

          # Test health endpoint
          echo "Testing health endpoint..."
          curl -s "$SERVICE_URL/actuator/health" | jq . || echo "Health endpoint test failed"

          # Test API health endpoint
          echo "Testing API health endpoint..."
          curl -s "$SERVICE_URL/api/v1/health" | jq . || echo "API health endpoint test failed"

          echo "âœ… Service tests completed!"
          EOF

          # Replace placeholder in test-service.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" test-service.sh
          chmod +x test-service.sh

      - name: Setup Python for database schema generation
        run: |
          # Install Python3 and PyYAML if not available
          if ! command -v python3 &> /dev/null; then
            echo "Installing Python3..."
            sudo apt-get update && sudo apt-get install -y python3 python3-pip
          fi

          if ! python3 -c "import yaml" 2>/dev/null; then
            echo "Installing PyYAML..."
            pip3 install PyYAML
          fi

      - name: Create database schema generation script
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create database directory
          mkdir -p src/main/resources/db/migration
          mkdir -p database/scripts

          # Create the Python script for schema generation
          cat > generate_schema.py << 'EOF'
          import yaml
          import json
          import re
          import os
          from datetime import datetime

          def openapi_type_to_postgres(openapi_type, format_type=None, enum_values=None):
              """Convert OpenAPI types to PostgreSQL types"""
              type_mapping = {
                  'string': {
                      'date': 'DATE',
                      'date-time': 'TIMESTAMP WITH TIME ZONE',
                      'uuid': 'UUID',
                      'uri': 'TEXT',
                      'url': 'TEXT',
                      'email': 'VARCHAR(255)',
                      'password': 'VARCHAR(255)',
                      None: 'TEXT'
                  },
                  'integer': {
                      'int32': 'INTEGER',
                      'int64': 'BIGINT',
                      None: 'INTEGER'
                  },
                  'number': {
                      'float': 'REAL',
                      'double': 'DOUBLE PRECISION',
                      'decimal': 'DECIMAL(10,2)',
                      None: 'DECIMAL(10,2)'
                  },
                  'boolean': {
                      None: 'BOOLEAN'
                  },
                  'array': {
                      None: 'JSONB'
                  },
                  'object': {
                      None: 'JSONB'
                  }
              }
              
              if enum_values:
                  return f"VARCHAR(50) CHECK (VALUE IN ({', '.join([f\"'{v}'\" for v in enum_values])}))"
              
              return type_mapping.get(openapi_type, {}).get(format_type, type_mapping.get(openapi_type, {}).get(None, 'TEXT'))

          def snake_case(name):
              """Convert camelCase or PascalCase to snake_case"""
              s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
              return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

          def generate_table_name(schema_name):
              """Generate table name from schema name"""
              table_name = schema_name
              for suffix in ['Response', 'Request', 'DTO', 'Entity']:
                  if table_name.endswith(suffix):
                      table_name = table_name[:-len(suffix)]
                      break
              return snake_case(table_name) + 's'

          try:
              # Load the OpenAPI spec
              with open('api-spec.yaml', 'r') as f:
                  spec = yaml.safe_load(f)
              
              schemas = spec.get('components', {}).get('schemas', {})
              
              # Generate SQL
              sql_statements = []
              sql_statements.append("-- Generated PostgreSQL schema from OpenAPI specification")
              sql_statements.append(f"-- Generated on: {datetime.now().isoformat()}")
              sql_statements.append("")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"pg_trgm\";")
              sql_statements.append("")
              
              # Generate tables for schemas
              for schema_name, schema_def in schemas.items():
                  if schema_def.get('type') == 'object' and 'properties' in schema_def:
                      if any(suffix in schema_name for suffix in ['Request', 'Response', 'Error', 'Paged']):
                          continue
                      
                      table_name = generate_table_name(schema_name)
                      sql_statements.append(f"CREATE TABLE IF NOT EXISTS {table_name} (")
                      sql_statements.append("    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),")
                      sql_statements.append("    name VARCHAR(255) NOT NULL,")
                      sql_statements.append("    description TEXT,")
                      sql_statements.append("    status VARCHAR(50) DEFAULT 'ACTIVE',")
                      sql_statements.append("    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    version BIGINT DEFAULT 1")
                      sql_statements.append(");")
                      sql_statements.append("")
              
              # Write files
              schema_content = '\n'.join(sql_statements)
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              print("âœ… Generated PostgreSQL schema successfully!")
              
          except Exception as e:
              print(f"âš ï¸  Could not generate database schema: {e}")
              # Create basic schema as fallback
              basic_schema = f"""-- Basic schema
          CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

          CREATE TABLE IF NOT EXISTS entities (
              id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
              name VARCHAR(255) NOT NULL,
              description TEXT,
              status VARCHAR(50) DEFAULT 'ACTIVE',
              created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              version BIGINT DEFAULT 1
          );"""
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              print("âœ… Generated basic database schema as fallback")
          EOF

      - name: Generate database schema
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          echo "ðŸ—„ï¸  Generating PostgreSQL database schema..."
          python3 generate_schema.py

      - name: Create database initialization scripts
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Add Flyway dependency to pom.xml for database migrations
          if [[ -f "pom.xml" ]]; then
            echo "ðŸ“¦ Adding Flyway for database migrations..."
            sed -i '/<\/dependencies>/i\
          		<dependency>\
          			<groupId>org.flywaydb</groupId>\
          			<artifactId>flyway-core</artifactId>\
          		</dependency>\
          		<dependency>\
          			<groupId>org.flywaydb</groupId>\
          			<artifactId>flyway-database-postgresql</artifactId>\
          		</dependency>' pom.xml
          fi

          # Create database initialization script
          cat > database/scripts/init-database.sh << 'EOF'
          #!/bin/bash
          set -e

          DB_NAME=${1:-"SERVICE_NAME_DB_PLACEHOLDER"}
          DB_USER=${2:-"postgres"}
          DB_PASSWORD=${3:-"password"}
          DB_HOST=${4:-"localhost"}
          DB_PORT=${5:-"5432"}

          echo "ðŸ—„ï¸  Initializing database: $DB_NAME"

          # Wait for PostgreSQL to be ready
          until PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c '\q'; do
            echo "â³ Waiting for PostgreSQL..."
            sleep 2
          done

          # Create database if it doesn't exist
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c "CREATE DATABASE \"$DB_NAME\""

          # Run schema script
          echo "ðŸ“‹ Running schema migrations..."
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f 001_initial_schema.sql

          echo "âœ… Database initialization completed!"
          EOF

          # Replace placeholder in init script
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" database/scripts/init-database.sh
          chmod +x database/scripts/init-database.sh

          # Create sample data script
          cat > database/scripts/002_sample_data.sql << EOF
          -- Sample data for $SERVICE_NAME
          -- Generated on: $(date -u +"%Y-%m-%dT%H:%M:%SZ")

          -- Insert sample data here
          -- Example:
          -- INSERT INTO entities (name, description, status) VALUES 
          --   ('Sample Entity 1', 'This is a sample entity for testing', 'ACTIVE'),
          --   ('Sample Entity 2', 'Another sample entity', 'ACTIVE');

          -- You can uncomment and modify the above lines to add sample data
          EOF

      - name: Create database documentation
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create database documentation
          cat > database/README.md << EOF
          # Database Schema for $SERVICE_NAME

          This directory contains the PostgreSQL database schema and related scripts for the $SERVICE_NAME.

          ## ðŸ“ Structure

          - \`scripts/\` - Database scripts and migrations
            - \`001_initial_schema.sql\` - Initial database schema
            - \`002_sample_data.sql\` - Sample data for development
            - \`init-database.sh\` - Database initialization script

          ## ðŸš€ Quick Start

          ### Using Docker Compose (Recommended)
          The database is automatically set up when you run:
          \`\`\`bash
          docker-compose up -d
          \`\`\`

          ### Manual Setup
          1. **Start PostgreSQL:**
             \`\`\`bash
             docker run -d --name postgres \\
               -e POSTGRES_DB=${SERVICE_NAME//-/_}_db \\
               -e POSTGRES_USER=postgres \\
               -e POSTGRES_PASSWORD=password \\
               -p 5432:5432 postgres:15
             \`\`\`

          2. **Initialize the database:**
             \`\`\`bash
             cd database/scripts
             ./init-database.sh
             \`\`\`

          3. **Connect to the database:**
             \`\`\`bash
             psql -h localhost -U postgres -d ${SERVICE_NAME//-/_}_db
             \`\`\`

          ## ðŸ“‹ Connection Details

          - **Host:** localhost
          - **Port:** 5432
          - **Database:** ${SERVICE_NAME//-/_}_db
          - **Username:** postgres
          - **Password:** password
          EOF

          echo "âœ… Generated complete PostgreSQL database setup!"
          echo "ðŸ“ Database files created:"
          find database -type f | head -10
      - name: Create Port service entity
        if: ${{ inputs.port_run_id != '' }}
        continue-on-error: true
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: UPSERT
          identifier: ${{ inputs.service_name }}
          title: "${{ inputs.service_name }} Service"
          blueprint: "service"
          properties: |
            {
              "description": "${{ inputs.description }}",
              "type": "microservice",
              "language": "java",
              "framework": "spring-boot",
              "port": 8080,
              "health_endpoint": "http://localhost:8080/actuator/health",
              "api_docs": "http://localhost:8080/swagger-ui.html",
              "status": "development",
              "version": "1.0.0",
              "created_by": "${{ github.actor }}",
              "created_at": "${{ github.event.head_commit.timestamp }}"
            }
          relations: |
            {
              "repository": "${{ github.repository }}"
            }

      - name: Create service directory and commit to current repository
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Default token works for current repo
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          # Create services directory if it doesn't exist
          mkdir -p services

          # Move generated code to services directory
          mv "$SERVICE_NAME" "services/$SERVICE_NAME"

          # Create README for the services directory
          if [[ ! -f "services/README.md" ]]; then
            cat > services/README.md << 'EOF'
          # Microservices

          This directory contains all the scaffolded microservices for the Event Management Platform.

          ## Services
          EOF
          fi

          # Add service to the README
          echo "- [\`$SERVICE_NAME\`](./services/$SERVICE_NAME) - ${{ inputs.description }}" >> services/README.md

          # Create comprehensive README for the service
          cd "services/$SERVICE_NAME"
          cat > README.md << EOF
          # $SERVICE_NAME

          ${{ inputs.description }}

          Generated Spring Boot microservice from OpenAPI specification.

          ## Quick Start

          1. **Navigate to service directory:**
             \`\`\`bash
             cd services/$SERVICE_NAME
             \`\`\`

          2. **Start with Docker Compose:**
             \`\`\`bash
             docker-compose up -d
             \`\`\`

          3. **Or run locally:**
             \`\`\`bash
             mvn spring-boot:run
             \`\`\`

          4. **Test the API:**
             \`\`\`bash
             curl http://localhost:8080/api/v1/health
             \`\`\`

          5. **View API Documentation:**
             \`\`\`
             http://localhost:8080/swagger-ui.html
             \`\`\`

          ## Generated Features

          âœ… **RESTful API** - Complete CRUD operations  
          âœ… **OpenAPI Documentation** - Interactive Swagger UI  
          âœ… **Data Validation** - Bean validation with error handling  
          âœ… **Pagination** - Built-in pagination support  
          âœ… **Docker Support** - Ready for containerization  
          âœ… **Database Integration** - PostgreSQL with JPA  
          âœ… **Health Checks** - Actuator endpoints  

          ## API Endpoints

          | Method | Endpoint | Description |
          |--------|----------|-------------|
          | GET | \`/api/v1/health\` | Health check |
          | GET | \`/api/v1/${SERVICE_NAME}s\` | List items with pagination |
          | POST | \`/api/v1/${SERVICE_NAME}s\` | Create new item |
          | GET | \`/api/v1/${SERVICE_NAME}s/{id}\` | Get item by ID |
          | PUT | \`/api/v1/${SERVICE_NAME}s/{id}\` | Update item |
          | DELETE | \`/api/v1/${SERVICE_NAME}s/{id}\` | Delete item |

          ## Development

          This service was generated using the Event Management Platform scaffolding system.

          - **Generated by:** ${{ github.actor }}
          - **Generated on:** $(date)
          - **Template:** OpenAPI Generator with Spring Boot

          ## Next Steps

          1. **Implement Business Logic** - Add your service implementation
          2. **Create JPA Entities** - Define your database entities  
          3. **Add Tests** - Write unit and integration tests
          4. **Configure Security** - Set up authentication
          5. **Add Monitoring** - Configure metrics and logging
          EOF

          cd ../..

          # Commit the changes
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          git add services/
          git commit -m "ðŸŽ‰ Add $SERVICE_NAME microservice

          Generated Spring Boot service with:
          âœ… Complete RESTful API from OpenAPI spec
          âœ… CRUD operations with validation
          âœ… Pagination and filtering support  
          âœ… Docker containerization
          âœ… PostgreSQL database integration
          âœ… Interactive API documentation
          âœ… Health monitoring endpoints

          Generated by: ${{ github.actor }}
          Description: ${{ inputs.description }}
          Location: services/$SERVICE_NAME/

          Next: Implement business logic and entities"

          git push origin main

          echo "âœ… Service '$SERVICE_NAME' created in services/ directory!"
          echo "ðŸ“ Location: services/$SERVICE_NAME/"
          echo "ðŸŒ Repository: https://github.com/${{ github.repository }}"
          echo "ðŸ“– API Documentation: http://localhost:8080/swagger-ui.html (after running)"

          - name: Log completion to Port
                    if: ${{ inputs.port_run_id != '' }}
                    continue-on-error: true
                    uses: port-labs/port-github-action@v1
                    with:
                      clientId: ${{ secrets.PORT_CLIENT_ID }}
                      clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
                      baseUrl: https://api.getport.io
                      operation: PATCH_RUN
                      runId: ${{ inputs.port_run_id }}
                      logMessage: "âœ… Successfully scaffolded service: ${{ inputs.service_name }}"
