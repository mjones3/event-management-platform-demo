# Save this as: .github/workflows/scaffold-service.yml

name: Scaffold a new service

on:
  workflow_dispatch:
    inputs:
      service_name:
        required: true
        description: "The name of the new service"
        type: string
      description:
        required: false
        description: "Description of the service"
        type: string
        default: "A new microservice"
      openapi_spec_url:
        required: false
        description: "URL to OpenAPI specification (leave empty to auto-generate)"
        type: string
        default: ""
      port_run_id:
        required: false
        description: "Port run ID for logging"
        type: string

env:
  ORG_NAME: your-org-name # Replace with your actual GitHub org/username

permissions:
  contents: write # Allow the workflow to push changes
  pull-requests: write # Allow creating PRs if needed

jobs:
  scaffold-service:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Display inputs (for debugging)
        run: |
          echo "=== INPUTS ==="
          echo "Service Name: ${{ inputs.service_name }}"
          echo "Description: ${{ inputs.description }}"
          echo "OpenAPI Spec URL: ${{ inputs.openapi_spec_url }}"
          echo "Port Run ID: ${{ inputs.port_run_id }}"
          echo ""
          echo "=== GITHUB CONTEXT ==="
          echo "Triggered by: ${{ github.actor }}"
          echo "Repository: ${{ github.repository }}"
          echo "Event: ${{ github.event_name }}"
          echo ""
          echo "=== PORT RUN ID CHECK ==="
          if [ -n "${{ inputs.port_run_id }}" ]; then
            echo "‚úÖ Port run ID is present: ${{ inputs.port_run_id }}"
          else
            echo "‚ùå Port run ID is missing"
          fi

      - name: Test Port connection (simple)
        if: ${{ inputs.port_run_id != '' }}
        continue-on-error: true
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: PATCH_RUN
          runId: ${{ inputs.port_run_id }}
          logMessage: "üöÄ Starting scaffolding of service: ${{ inputs.service_name }}"

      - name: Set up Java for OpenAPI generation
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"

      - name: Enhance generated service with microservice features
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          # Ensure directory exists
          if [[ ! -d "$SERVICE_NAME" ]]; then
            echo "‚ùå Service directory not found: $SERVICE_NAME"
            exit 1
          fi

          cd "$SERVICE_NAME"

          # Check if we have a pom.xml and enhance it
          if [[ -f "pom.xml" ]]; then
            echo "üì¶ Enhancing pom.xml with additional dependencies..."
            
            # Create a backup
            cp pom.xml pom.xml.backup
            
            # Function to check if dependency exists
            check_dependency() {
              local groupId=$1
              local artifactId=$2
              grep -q "<groupId>$groupId</groupId>" pom.xml && \
              grep -A1 "<groupId>$groupId</groupId>" pom.xml | grep -q "<artifactId>$artifactId</artifactId>"
            }
            
            # Build list of dependencies to add (only if they don't exist)
            DEPS_TO_ADD=""
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-data-jpa"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-data-jpa</artifactId>
          		</dependency>"
            else
              echo "spring-boot-starter-data-jpa already exists"
            fi
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-actuator"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-actuator</artifactId>
          		</dependency>"
            else
              echo "spring-boot-starter-actuator already exists"
            fi
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-validation"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-validation</artifactId>
          		</dependency>"
            else
              echo "spring-boot-starter-validation already exists"
            fi
            
            if ! check_dependency "org.postgresql" "postgresql"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.postgresql</groupId>
          			<artifactId>postgresql</artifactId>
          			<scope>runtime</scope>
          		</dependency>"
            else
              echo "postgresql already exists"
            fi
            
            if ! check_dependency "io.micrometer" "micrometer-registry-prometheus"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>io.micrometer</groupId>
          			<artifactId>micrometer-registry-prometheus</artifactId>
          		</dependency>"
            else
              echo "micrometer-registry-prometheus already exists"
            fi
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-test"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-test</artifactId>
          			<scope>test</scope>
          		</dependency>"
            else
              echo "spring-boot-starter-test already exists"
            fi
            
            if ! check_dependency "org.flywaydb" "flyway-core"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.flywaydb</groupId>
          			<artifactId>flyway-core</artifactId>
          		</dependency>"
            else
              echo "flyway-core already exists"
            fi
            
            if ! check_dependency "org.flywaydb" "flyway-database-postgresql"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.flywaydb</groupId>
          			<artifactId>flyway-database-postgresql</artifactId>
          		</dependency>"
            else
              echo "flyway-database-postgresql already exists"
            fi
            
            # Add dependencies if any were collected
            if [[ -n "$DEPS_TO_ADD" ]]; then
              echo "Adding new dependencies..."
              # Create temp file with additional dependencies
              cat > additional_deps.txt << EOF
          		<!-- Additional Spring Boot Dependencies -->$DEPS_TO_ADD
          EOF
              
              # Insert before </dependencies>
              sed -i '/<\/dependencies>/e cat additional_deps.txt' pom.xml
              rm additional_deps.txt
            else
              echo "All required dependencies already exist"
            fi
            
            # Check if Spring Boot Maven plugin already exists, if not add it
            if ! grep -q "spring-boot-maven-plugin" pom.xml; then
              echo "Adding Spring Boot Maven plugin..."
              # Only add build section if it doesn't exist
              if ! grep -q "<build>" pom.xml; then
                sed -i '/<\/project>/i\
          	<build>\
          		<plugins>\
          			<plugin>\
          				<groupId>org.springframework.boot</groupId>\
          				<artifactId>spring-boot-maven-plugin</artifactId>\
          				<configuration>\
          					<excludes>\
          						<exclude>\
          							<groupId>org.projectlombok</groupId>\
          							<artifactId>lombok</artifactId>\
          						</exclude>\
          					</excludes>\
          				</configuration>\
          			</plugin>\
          		</plugins>\
          	</build>' pom.xml
              else
                # Build section exists, just add the plugin to existing plugins section
                if grep -q "<plugins>" pom.xml; then
                  sed -i '/<\/plugins>/i\
          			<plugin>\
          				<groupId>org.springframework.boot</groupId>\
          				<artifactId>spring-boot-maven-plugin</artifactId>\
          				<configuration>\
          					<excludes>\
          						<exclude>\
          							<groupId>org.projectlombok</groupId>\
          							<artifactId>lombok</artifactId>\
          						</exclude>\
          					</excludes>\
          				</configuration>\
          			</plugin>' pom.xml
                else
                  # Build exists but no plugins section
                  sed -i '/<\/build>/i\
          		<plugins>\
          			<plugin>\
          				<groupId>org.springframework.boot</groupId>\
          				<artifactId>spring-boot-maven-plugin</artifactId>\
          				<configuration>\
          					<excludes>\
          						<exclude>\
          							<groupId>org.projectlombok</groupId>\
          							<artifactId>lombok</artifactId>\
          						</exclude>\
          					</excludes>\
          				</configuration>\
          			</plugin>\
          		</plugins>' pom.xml
                fi
              fi
            else
              echo "Spring Boot Maven plugin already exists, skipping..."
            fi
            
            echo "‚úÖ Enhanced pom.xml successfully"
            echo "üìÑ Final pom.xml validation:"
            if mvn help:effective-pom -q > /dev/null 2>&1; then
              echo "‚úÖ pom.xml is valid"
            else
              echo "‚ùå pom.xml has issues, showing structure:"
              grep -n "groupId\|artifactId\|version" pom.xml | head -30
            fi
          else
            echo "‚ùå No pom.xml found to enhance"
          fi

      - name: Create main application class
        working-directory: ${{ inputs.service_name }}
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          # Find the main application class and ensure it exists and is correct
          PACKAGE_DIR="src/main/java/com/eventplatform/$(echo $SERVICE_NAME | tr '-' '/')"
          MAIN_CLASS_NAME="$(echo $SERVICE_NAME | sed 's/-//g' | sed 's/\b\w/\U&/g')Application"

          echo "üìù Creating/updating main application class: $MAIN_CLASS_NAME"

          # Create the main application class
          mkdir -p "$PACKAGE_DIR"
          cat > "$PACKAGE_DIR/${MAIN_CLASS_NAME}.java" << EOF
          package com.eventplatform.$(echo $SERVICE_NAME | tr '-' '.');

          import org.springframework.boot.SpringApplication;
          import org.springframework.boot.autoconfigure.SpringBootApplication;
          import org.springframework.web.bind.annotation.GetMapping;
          import org.springframework.web.bind.annotation.RestController;
          import java.util.Map;
          import java.util.HashMap;

          @SpringBootApplication
          public class ${MAIN_CLASS_NAME} {
              public static void main(String[] args) {
                  SpringApplication.run(${MAIN_CLASS_NAME}.class, args);
              }
          }

          @RestController
          class HealthController {
              
              @GetMapping("/")
              public Map<String, Object> root() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("service", "$SERVICE_NAME");
                  response.put("status", "UP");
                  response.put("message", "Welcome to $SERVICE_NAME API");
                  response.put("documentation", "/swagger-ui.html");
                  response.put("health", "/actuator/health");
                  return response;
              }
              
              @GetMapping("/api/v1/health")
              public Map<String, Object> health() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("status", "UP");
                  response.put("service", "$SERVICE_NAME");
                  response.put("timestamp", java.time.Instant.now().toString());
                  response.put("version", "1.0.0");
                  return response;
              }
          }
          EOF

      - name: Create application configuration files
        working-directory: ${{ inputs.service_name }}
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          # Create application.yml with proper configuration
          mkdir -p src/main/resources
          cat > src/main/resources/application.yml << 'EOF'
          server:
            port: ${PORT:8080}

          spring:
            application:
              name: SERVICE_NAME_PLACEHOLDER
            datasource:
              url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:SERVICE_NAME_DB_PLACEHOLDER}
              username: ${DB_USERNAME:postgres}
              password: ${DB_PASSWORD:password}
            jpa:
              hibernate:
                ddl-auto: ${JPA_DDL_AUTO:create-drop}
              show-sql: ${JPA_SHOW_SQL:false}
              properties:
                hibernate:
                  format_sql: true
                  dialect: org.hibernate.dialect.PostgreSQLDialect
            
          management:
            endpoints:
              web:
                exposure:
                  include: health,info,metrics,prometheus
            endpoint:
              health:
                show-details: always
            metrics:
              export:
                prometheus:
                  enabled: true

          logging:
            level:
              com.eventplatform: ${LOG_LEVEL:INFO}
              org.springframework.web: ${WEB_LOG_LEVEL:WARN}
              org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}

          springdoc:
            api-docs:
              path: /api-docs
            swagger-ui:
              path: /swagger-ui.html
              operations-sorter: method
          EOF

          # Replace placeholders in application.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" src/main/resources/application.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" src/main/resources/application.yml

          # Create application.properties as fallback
          cat > src/main/resources/application.properties << EOF
          # Application Configuration
          spring.application.name=$SERVICE_NAME
          server.port=8080

          # Database Configuration
          spring.datasource.url=jdbc:postgresql://localhost:5432/${SERVICE_NAME//-/_}_db
          spring.datasource.username=postgres
          spring.datasource.password=password
          spring.jpa.hibernate.ddl-auto=create-drop
          spring.jpa.show-sql=false

          # Actuator Configuration
          management.endpoints.web.exposure.include=health,info,metrics
          management.endpoint.health.show-details=always

          # Logging Configuration
          logging.level.com.eventplatform=INFO
          EOF

      - name: Build Spring Boot application
        working-directory: ${{ inputs.service_name }}
        run: |

          echo "üîß Building the Spring Boot application..."

          # Build the application
          if command -v mvn &> /dev/null; then
            echo "üì¶ Building with Maven..."
            mvn clean package -DskipTests -q
            
            # Check if JAR was created
            if [[ -f target/*.jar ]]; then
              echo "‚úÖ JAR built successfully:"
              ls -la target/*.jar
            else
              echo "‚ùå JAR build failed, creating minimal JAR structure..."
              mkdir -p target
              # We'll handle this in the Docker build
            fi
          else
            echo "‚ö†Ô∏è  Maven not available, will build in Docker"
          fi

      - name: Create Docker configuration
        working-directory: ${{ inputs.service_name }}
        run: |

          # Create an enhanced Dockerfile with multi-stage build
          cat > Dockerfile << 'EOF'
          # Multi-stage build for Spring Boot application
          FROM maven:3.9-openjdk-17-slim AS builder

          WORKDIR /app

          # Copy pom.xml first for better caching
          COPY pom.xml .

          # Download dependencies
          RUN mvn dependency:go-offline -B

          # Copy source code
          COPY src ./src

          # Build the application
          RUN mvn clean package -DskipTests -B

          # Runtime stage
          FROM openjdk:17-jdk-slim

          WORKDIR /app

          # Copy the JAR from builder stage
          COPY --from=builder /app/target/*.jar app.jar

          # Create non-root user
          RUN addgroup --system spring && adduser --system spring --ingroup spring
          USER spring:spring

          # Expose port
          EXPOSE 8080

          # Health check
          HEALTHCHECK --interval=30s --timeout=3s --start-period=30s --retries=3 \
              CMD curl -f http://localhost:8080/actuator/health || exit 1

          # Run the application
          ENTRYPOINT ["java", "-jar", "app.jar"]
          EOF

      - name: Create Docker Compose configuration
        working-directory: ${{ inputs.service_name }}
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          # Create docker-compose.yml with working setup
          cat > docker-compose.yml << 'EOF'
          version: '3.8'
          services:
            SERVICE_NAME_PLACEHOLDER:
              build: .
              ports:
                - "${SERVICE_PORT:-8080}:8080"
              environment:
                - SPRING_PROFILES_ACTIVE=docker
                - DB_HOST=postgres
                - DB_USERNAME=postgres
                - DB_PASSWORD=password
                - DB_NAME=SERVICE_NAME_DB_PLACEHOLDER
              depends_on:
                postgres:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
            
            postgres:
              image: postgres:15-alpine
              environment:
                - POSTGRES_DB=SERVICE_NAME_DB_PLACEHOLDER
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=password
              ports:
                - "${DB_PORT:-5432}:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5

          volumes:
            postgres_data:
          EOF

          # Replace placeholders in docker-compose.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" docker-compose.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" docker-compose.yml

      - name: Create utility scripts
        working-directory: ${{ inputs.service_name }}
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          # Create a startup script
          cat > start.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "üöÄ Starting SERVICE_NAME_PLACEHOLDER..."

          # Check if Docker is available
          if command -v docker &> /dev/null; then
              echo "üê≥ Starting with Docker Compose..."
              docker-compose up --build -d
              
              echo "‚è≥ Waiting for services to be healthy..."
              sleep 30
              
              echo "üîç Checking service health..."
              curl -f http://localhost:8080/actuator/health || echo "‚ùå Health check failed"
              
              echo "üìñ API Documentation: http://localhost:8080/swagger-ui.html"
              echo "‚ù§Ô∏è  Health Endpoint: http://localhost:8080/actuator/health"
              echo "üè† Service Root: http://localhost:8080/"
          else
              echo "üì¶ Building with Maven..."
              mvn clean package -DskipTests
              
              echo "‚òï Starting Spring Boot application..."
              java -jar target/*.jar
          fi
          EOF

          # Replace placeholder in start.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" start.sh
          chmod +x start.sh

          # Create a test script
          cat > test-service.sh << 'EOF'
          #!/bin/bash
          set -e

          SERVICE_URL="http://localhost:8080"

          echo "üß™ Testing SERVICE_NAME_PLACEHOLDER..."

          # Test root endpoint
          echo "Testing root endpoint..."
          curl -s "$SERVICE_URL/" | jq . || echo "Root endpoint test failed"

          # Test health endpoint
          echo "Testing health endpoint..."
          curl -s "$SERVICE_URL/actuator/health" | jq . || echo "Health endpoint test failed"

          # Test API health endpoint
          echo "Testing API health endpoint..."
          curl -s "$SERVICE_URL/api/v1/health" | jq . || echo "API health endpoint test failed"

          echo "‚úÖ Service tests completed!"
          EOF

          # Replace placeholder in test-service.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" test-service.sh
          chmod +x test-service.sh

      - name: Setup Python for database schema generation
        run: |
          # Install Python3 and PyYAML if not available
          if ! command -v python3 &> /dev/null; then
            echo "Installing Python3..."
            sudo apt-get update && sudo apt-get install -y python3 python3-pip
          fi

          if ! python3 -c "import yaml" 2>/dev/null; then
            echo "Installing PyYAML..."
            pip3 install PyYAML
          fi

      - name: Create database schema generation script
        working-directory: ${{ inputs.service_name }}
        run: |

          # Create database directory
          mkdir -p src/main/resources/db/migration
          mkdir -p database/scripts

          # Create the Python script for schema generation
          cat > generate_schema.py << 'EOF'
          import yaml
          import json
          import re
          import os
          from datetime import datetime

          def openapi_type_to_postgres(openapi_type, format_type=None, enum_values=None):
              """Convert OpenAPI types to PostgreSQL types"""
              type_mapping = {
                  'string': {
                      'date': 'DATE',
                      'date-time': 'TIMESTAMP WITH TIME ZONE',
                      'uuid': 'UUID',
                      'uri': 'TEXT',
                      'url': 'TEXT',
                      'email': 'VARCHAR(255)',
                      'password': 'VARCHAR(255)',
                      None: 'TEXT'
                  },
                  'integer': {
                      'int32': 'INTEGER',
                      'int64': 'BIGINT',
                      None: 'INTEGER'
                  },
                  'number': {
                      'float': 'REAL',
                      'double': 'DOUBLE PRECISION',
                      'decimal': 'DECIMAL(10,2)',
                      None: 'DECIMAL(10,2)'
                  },
                  'boolean': {
                      None: 'BOOLEAN'
                  },
                  'array': {
                      None: 'JSONB'
                  },
                  'object': {
                      None: 'JSONB'
                  }
              }
              
              if enum_values:
                  return f"VARCHAR(50) CHECK (VALUE IN ({', '.join([f\"'{v}'\" for v in enum_values])}))"
              
              return type_mapping.get(openapi_type, {}).get(format_type, type_mapping.get(openapi_type, {}).get(None, 'TEXT'))

          def snake_case(name):
              """Convert camelCase or PascalCase to snake_case"""
              s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
              return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

          def generate_table_name(schema_name):
              """Generate table name from schema name"""
              table_name = schema_name
              for suffix in ['Response', 'Request', 'DTO', 'Entity']:
                  if table_name.endswith(suffix):
                      table_name = table_name[:-len(suffix)]
                      break
              return snake_case(table_name) + 's'

          try:
              # Load the OpenAPI spec
              with open('api-spec.yaml', 'r') as f:
                  spec = yaml.safe_load(f)
              
              schemas = spec.get('components', {}).get('schemas', {})
              
              # Generate SQL
              sql_statements = []
              sql_statements.append("-- Generated PostgreSQL schema from OpenAPI specification")
              sql_statements.append(f"-- Generated on: {datetime.now().isoformat()}")
              sql_statements.append("")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"pg_trgm\";")
              sql_statements.append("")
              
              # Generate tables for schemas
              for schema_name, schema_def in schemas.items():
                  if schema_def.get('type') == 'object' and 'properties' in schema_def:
                      if any(suffix in schema_name for suffix in ['Request', 'Response', 'Error', 'Paged']):
                          continue
                      
                      table_name = generate_table_name(schema_name)
                      sql_statements.append(f"CREATE TABLE IF NOT EXISTS {table_name} (")
                      sql_statements.append("    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),")
                      sql_statements.append("    name VARCHAR(255) NOT NULL,")
                      sql_statements.append("    description TEXT,")
                      sql_statements.append("    status VARCHAR(50) DEFAULT 'ACTIVE',")
                      sql_statements.append("    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    version BIGINT DEFAULT 1")
                      sql_statements.append(");")
                      sql_statements.append("")
              
              # Write files
              schema_content = '\n'.join(sql_statements)
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              print("‚úÖ Generated PostgreSQL schema successfully!")
              
          except Exception as e:
              print(f"‚ö†Ô∏è  Could not generate database schema: {e}")
              # Create basic schema as fallback
              basic_schema = f"""-- Basic schema
          CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

          CREATE TABLE IF NOT EXISTS entities (
              id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
              name VARCHAR(255) NOT NULL,
              description TEXT,
              status VARCHAR(50) DEFAULT 'ACTIVE',
              created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              version BIGINT DEFAULT 1
          );"""
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              print("‚úÖ Generated basic database schema as fallback")
          EOF

      - name: Generate database schema
        working-directory: ${{ inputs.service_name }}
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          echo "üóÑÔ∏è  Generating PostgreSQL database schema..."
          python3 generate_schema.py

      - name: Create database initialization scripts
        working-directory: ${{ inputs.service_name }}
        run: |

          # Create database initialization script
          cat > database/scripts/init-database.sh << 'EOF'
          #!/bin/bash
          set -e

          DB_NAME=${1:-"SERVICE_NAME_DB_PLACEHOLDER"}
          DB_USER=${2:-"postgres"}
          DB_PASSWORD=${3:-"password"}
          DB_HOST=${4:-"localhost"}
          DB_PORT=${5:-"5432"}

          echo "üóÑÔ∏è  Initializing database: $DB_NAME"

          # Wait for PostgreSQL to be ready
          until PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c '\q'; do
            echo "‚è≥ Waiting for PostgreSQL..."
            sleep 2
          done

          # Create database if it doesn't exist
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c "CREATE DATABASE \"$DB_NAME\""

          # Run schema script
          echo "üìã Running schema migrations..."
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f 001_initial_schema.sql

          echo "‚úÖ Database initialization completed!"
          EOF

          # Replace placeholder in init script
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" database/scripts/init-database.sh
          chmod +x database/scripts/init-database.sh

          # Create sample data script
          cat > database/scripts/002_sample_data.sql << EOF
          -- Sample data for $SERVICE_NAME
          -- Generated on: $(date -u +"%Y-%m-%dT%H:%M:%SZ")

          -- Insert sample data here
          -- Example:
          -- INSERT INTO entities (name, description, status) VALUES 
          --   ('Sample Entity 1', 'This is a sample entity for testing', 'ACTIVE'),
          --   ('Sample Entity 2', 'Another sample entity', 'ACTIVE');

          -- You can uncomment and modify the above lines to add sample data
          EOF

      - name: Create database documentation
        working-directory: ${{ inputs.service_name }}
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          # Create database documentation
          cat > database/README.md << EOF
          # Database Schema for $SERVICE_NAME

          This directory contains the PostgreSQL database schema and related scripts for the $SERVICE_NAME.

          ## üìÅ Structure

          - \`scripts/\` - Database scripts and migrations
            - \`001_initial_schema.sql\` - Initial database schema
            - \`002_sample_data.sql\` - Sample data for development
            - \`init-database.sh\` - Database initialization script

          ## üöÄ Quick Start

          ### Using Docker Compose (Recommended)
          The database is automatically set up when you run:
          \`\`\`bash
          docker-compose up -d
          \`\`\`

          ### Manual Setup
          1. **Start PostgreSQL:**
             \`\`\`bash
             docker run -d --name postgres \\
               -e POSTGRES_DB=${SERVICE_NAME//-/_}_db \\
               -e POSTGRES_USER=postgres \\
               -e POSTGRES_PASSWORD=password \\
               -p 5432:5432 postgres:15
             \`\`\`

          2. **Initialize the database:**
             \`\`\`bash
             cd database/scripts
             ./init-database.sh
             \`\`\`

          3. **Connect to the database:**
             \`\`\`bash
             psql -h localhost -U postgres -d ${SERVICE_NAME//-/_}_db
             \`\`\`

          ## üìã Connection Details

          - **Host:** localhost
          - **Port:** 5432
          - **Database:** ${SERVICE_NAME//-/_}_db
          - **Username:** postgres
          - **Password:** password
          EOF

          echo "‚úÖ Generated complete PostgreSQL database setup!"
          echo "üìÅ Database files created:"
          find database -type f | head -10
      - name: Create Port service entity
        if: ${{ inputs.port_run_id != '' }}
        continue-on-error: true
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: UPSERT
          identifier: ${{ inputs.service_name }}
          title: "${{ inputs.service_name }} Service"
          blueprint: "service"
          properties: |
            {
              "description": "${{ inputs.description }}",
              "type": "microservice",
              "language": "java",
              "framework": "spring-boot",
              "port": 8080,
              "health_endpoint": "http://localhost:8080/actuator/health",
              "api_docs": "http://localhost:8080/swagger-ui.html",
              "status": "development",
              "version": "1.0.0",
              "created_by": "${{ github.actor }}",
              "created_at": "${{ github.event.head_commit.timestamp }}"
            }
          relations: |
            {
              "repository": "${{ github.repository }}"
            }

      - name: Create service directory and commit to current repository
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Default token works for current repo
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          # Create services directory if it doesn't exist
          mkdir -p services

          # Move generated code to services directory
          mv "$SERVICE_NAME" "services/$SERVICE_NAME"

          # Create README for the services directory
          if [[ ! -f "services/README.md" ]]; then
            cat > services/README.md << 'EOF'
          # Microservices

          This directory contains all the scaffolded microservices for the Event Management Platform.

          ## Services
          EOF
          fi

          # Add service to the README
          echo "- [\`$SERVICE_NAME\`](./services/$SERVICE_NAME) - ${{ inputs.description }}" >> services/README.md

          # Create comprehensive README for the service
          cd "services/$SERVICE_NAME"
          cat > README.md << EOF
          # $SERVICE_NAME

          ${{ inputs.description }}

          Generated Spring Boot microservice from OpenAPI specification.

          ## Quick Start

          1. **Navigate to service directory:**
             \`\`\`bash
             cd services/$SERVICE_NAME
             \`\`\`

          2. **Start with Docker Compose:**
             \`\`\`bash
             docker-compose up -d
             \`\`\`

          3. **Or run locally:**
             \`\`\`bash
             mvn spring-boot:run
             \`\`\`

          4. **Test the API:**
             \`\`\`bash
             curl http://localhost:8080/api/v1/health
             \`\`\`

          5. **View API Documentation:**
             \`\`\`
             http://localhost:8080/swagger-ui.html
             \`\`\`

          ## Generated Features

          ‚úÖ **RESTful API** - Complete CRUD operations  
          ‚úÖ **OpenAPI Documentation** - Interactive Swagger UI  
          ‚úÖ **Data Validation** - Bean validation with error handling  
          ‚úÖ **Pagination** - Built-in pagination support  
          ‚úÖ **Docker Support** - Ready for containerization  
          ‚úÖ **Database Integration** - PostgreSQL with JPA  
          ‚úÖ **Health Checks** - Actuator endpoints  

          ## API Endpoints

          | Method | Endpoint | Description |
          |--------|----------|-------------|
          | GET | \`/api/v1/health\` | Health check |
          | GET | \`/api/v1/${SERVICE_NAME}s\` | List items with pagination |
          | POST | \`/api/v1/${SERVICE_NAME}s\` | Create new item |
          | GET | \`/api/v1/${SERVICE_NAME}s/{id}\` | Get item by ID |
          | PUT | \`/api/v1/${SERVICE_NAME}s/{id}\` | Update item |
          | DELETE | \`/api/v1/${SERVICE_NAME}s/{id}\` | Delete item |

          ## Development

          This service was generated using the Event Management Platform scaffolding system.

          - **Generated by:** ${{ github.actor }}
          - **Generated on:** $(date)
          - **Template:** OpenAPI Generator with Spring Boot

          ## Next Steps

          1. **Implement Business Logic** - Add your service implementation
          2. **Create JPA Entities** - Define your database entities  
          3. **Add Tests** - Write unit and integration tests
          4. **Configure Security** - Set up authentication
          5. **Add Monitoring** - Configure metrics and logging
          EOF

          cd ../..

          # Commit the changes
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          git add services/
          git commit -m "üéâ Add $SERVICE_NAME microservice

          Generated Spring Boot service with:
          ‚úÖ Complete RESTful API from OpenAPI spec
          ‚úÖ CRUD operations with validation
          ‚úÖ Pagination and filtering support  
          ‚úÖ Docker containerization
          ‚úÖ PostgreSQL database integration
          ‚úÖ Interactive API documentation
          ‚úÖ Health monitoring endpoints

          Generated by: ${{ github.actor }}
          Description: ${{ inputs.description }}
          Location: services/$SERVICE_NAME/

          Next: Implement business logic and entities"

          git push origin main

          echo "‚úÖ Service '$SERVICE_NAME' created in services/ directory!"
          echo "üìÅ Location: services/$SERVICE_NAME/"
          echo "üåê Repository: https://github.com/${{ github.repository }}"
          echo "üìñ API Documentation: http://localhost:8080/swagger-ui.html (after running)"

          - name: Log completion to Port
                    if: ${{ inputs.port_run_id != '' }}
                    continue-on-error: true
                    uses: port-labs/port-github-action@v1
                    with:
                      clientId: ${{ secrets.PORT_CLIENT_ID }}
                      clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
                      baseUrl: https://api.getport.io
                      operation: PATCH_RUN
                      runId: ${{ inputs.port_run_id }}
                      logMessage: "‚úÖ Successfully scaffolded service: ${{ inputs.service_name }}"
