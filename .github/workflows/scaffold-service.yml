# Save this as: .github/workflows/scaffold-service.yml

name: Scaffold a new service

on:
  workflow_dispatch:
    inputs:
      service_name:
        required: true
        description: "The name of the new service"
        type: string
      description:
        required: false
        description: "Description of the service"
        type: string
        default: "A new microservice"
      openapi_spec_url:
        required: false
        description: "URL to OpenAPI specification (leave empty to auto-generate)"
        type: string
        default: ""
      port_run_id:
        required: false
        description: "Port run ID for logging"
        type: string

env:
  ORG_NAME: your-org-name # Replace with your actual GitHub org/username

permissions:
  contents: write # Allow the workflow to push changes
  pull-requests: write # Allow creating PRs if needed

jobs:
  scaffold-service:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Display inputs (for debugging)
        run: |
          echo "=== INPUTS ==="
          echo "Service Name: ${{ inputs.service_name }}"
          echo "Description: ${{ inputs.description }}"
          echo "OpenAPI Spec URL: ${{ inputs.openapi_spec_url }}"
          echo "Port Run ID: ${{ inputs.port_run_id }}"
          echo ""
          echo "=== GITHUB CONTEXT ==="
          echo "Triggered by: ${{ github.actor }}"
          echo "Repository: ${{ github.repository }}"
          echo "Event: ${{ github.event_name }}"
          echo ""
          echo "=== PORT RUN ID CHECK ==="
          if [ -n "${{ inputs.port_run_id }}" ]; then
            echo "✅ Port run ID is present: ${{ inputs.port_run_id }}"
          else
            echo "❌ Port run ID is missing"
          fi

      - name: Test Port connection (simple)
        if: ${{ inputs.port_run_id != '' }}
        continue-on-error: true
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: PATCH_RUN
          runId: ${{ inputs.port_run_id }}
          logMessage: "🚀 Starting scaffolding of service: ${{ inputs.service_name }}"

      - name: Set up Java for OpenAPI generation
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"

      - name: Generate Spring Boot service from OpenAPI spec
        run: |
          set -e  # Exit on any error
          SERVICE_NAME="${{ inputs.service_name }}"

          echo "🔧 Starting service generation for: $SERVICE_NAME"

          # Validate service name
          if [[ ! "$SERVICE_NAME" =~ ^[a-z][a-z0-9-]*[a-z0-9]$ ]] || [[ ${#SERVICE_NAME} -lt 3 ]] || [[ ${#SERVICE_NAME} -gt 50 ]]; then
            echo "❌ Invalid service name: $SERVICE_NAME"
            echo "Service name must be 3-50 characters, lowercase, kebab-case (e.g., my-service)"
            exit 1
          fi

          # Create directory for the new service
          mkdir -p "$SERVICE_NAME"
          cd "$SERVICE_NAME"

          # Download OpenAPI Generator CLI
          echo "📥 Downloading OpenAPI Generator..."
          if ! wget -q https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/7.2.0/openapi-generator-cli-7.2.0.jar -O openapi-generator-cli.jar; then
            echo "❌ Failed to download OpenAPI Generator"
            exit 1
          fi

          # Verify download
          if [[ ! -f "openapi-generator-cli.jar" ]] || [[ ! -s "openapi-generator-cli.jar" ]]; then
            echo "❌ OpenAPI Generator download failed or file is empty"
            exit 1
          fi

          echo "✅ OpenAPI Generator downloaded successfully ($(ls -lh openapi-generator-cli.jar | awk '{print $5}'))"

          # Download your actual OpenAPI spec
          echo "📋 Fetching OpenAPI specification..."

          SPEC_FOUND=false

          # Check if user provided a custom OpenAPI spec URL
          if [ -n "${{ inputs.openapi_spec_url }}" ]; then
            echo "🌐 Using provided OpenAPI spec URL: ${{ inputs.openapi_spec_url }}"
            if wget -q "${{ inputs.openapi_spec_url }}" -O api-spec.yaml && [[ -s api-spec.yaml ]]; then
              echo "✅ Downloaded OpenAPI spec from provided URL"
              SPEC_FOUND=true
              
              # Validate it's actually an OpenAPI spec
              if grep -q "openapi\|swagger" api-spec.yaml; then
                echo "✅ Valid OpenAPI/Swagger specification detected"
              else
                echo "⚠️  File downloaded but doesn't appear to be an OpenAPI spec"
                echo "First few lines:"
                head -5 api-spec.yaml
                echo "Continuing anyway..."
              fi
            else
              echo "❌ Failed to download from provided URL: ${{ inputs.openapi_spec_url }}"
              echo "Will fall back to repository search or template generation"
            fi
          fi

          # Try multiple locations for the OpenAPI spec if no custom URL provided or custom URL failed
          if [[ "$SPEC_FOUND" == "false" ]]; then
            echo "🔍 Searching for OpenAPI spec in repository..."
            
            if wget -q https://raw.githubusercontent.com/mjones3/event-management-platform-demo/main/api-specs/user-service.yaml -O api-spec.yaml 2>/dev/null && [[ -s api-spec.yaml ]]; then
              echo "✅ Downloaded OpenAPI spec from api-specs directory"
              SPEC_FOUND=true
            elif wget -q https://raw.githubusercontent.com/mjones3/event-management-platform-demo/main/openapi/user-service.yaml -O api-spec.yaml 2>/dev/null && [[ -s api-spec.yaml ]]; then
              echo "✅ Downloaded OpenAPI spec from openapi directory"
              SPEC_FOUND=true
            elif wget -q https://raw.githubusercontent.com/mjones3/event-management-platform-demo/main/docs/api/user-service.yaml -O api-spec.yaml 2>/dev/null && [[ -s api-spec.yaml ]]; then
              echo "✅ Downloaded OpenAPI spec from docs directory"
              SPEC_FOUND=true
            fi
          fi

          if [[ "$SPEC_FOUND" == "false" ]]; then
            echo "⚠️  Could not find existing OpenAPI spec, creating a template based on service name..."
            
            # Create a generic microservice spec based on the service name
            SERVICE_NAME_CAMEL="$(echo ${SERVICE_NAME} | sed 's/-\([a-z]\)/\U\1/g' | sed 's/^\([a-z]\)/\U\1/')"
            
            cat > api-spec.yaml << 'SPEC_EOF'
          openapi: 3.0.3
          info:
            title: SERVICE_NAME_CAMEL_PLACEHOLDER Service API
            description: SERVICE_DESCRIPTION_PLACEHOLDER
            version: 1.0.0
            contact:
              name: API Support
              email: support@eventplatform.com
          servers:
            - url: https://api.eventplatform.com/SERVICE_NAME_PLACEHOLDER/v1
              description: Production server
            - url: http://localhost:8080/api/v1
              description: Development server

          security:
            - BearerAuth: []

          paths:
            /health:
              get:
                summary: Health check endpoint
                description: Returns the health status of the service
                tags:
                  - Health
                security: []
                responses:
                  '200':
                    description: Service is healthy
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/HealthResponse'
            
            /SERVICE_NAME_PLACEHOLDER_PLURAL:
              get:
                summary: List SERVICE_NAME_PLACEHOLDER_PLURAL with pagination
                description: Retrieve a paginated list with optional filtering
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                parameters:
                  - name: page
                    in: query
                    description: Page number (0-based)
                    schema:
                      type: integer
                      minimum: 0
                      default: 0
                  - name: size
                    in: query
                    description: Page size
                    schema:
                      type: integer
                      minimum: 1
                      maximum: 100
                      default: 20
                  - name: search
                    in: query
                    description: Search term
                    schema:
                      type: string
                      minLength: 2
                responses:
                  '200':
                    description: Successfully retrieved items
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/PagedSERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  '400':
                    $ref: '#/components/responses/BadRequest'
                  '401':
                    $ref: '#/components/responses/Unauthorized'
              post:
                summary: Create a new item
                description: Create a new item in the system
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                requestBody:
                  required: true
                  content:
                    application/json:
                      schema:
                        $ref: '#/components/schemas/CreateSERVICE_NAME_CAMEL_PLACEHOLDERRequest'
                responses:
                  '201':
                    description: Item created successfully
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/SERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  '400':
                    $ref: '#/components/responses/BadRequest'
                  '401':
                    $ref: '#/components/responses/Unauthorized'
            
            /SERVICE_NAME_PLACEHOLDER_PLURAL/{id}:
              get:
                summary: Get item by ID
                description: Retrieve detailed information about a specific item
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                parameters:
                  - name: id
                    in: path
                    required: true
                    description: Item ID
                    schema:
                      type: string
                      format: uuid
                responses:
                  '200':
                    description: Item found
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/SERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  '404':
                    $ref: '#/components/responses/NotFound'
                  '401':
                    $ref: '#/components/responses/Unauthorized'
              put:
                summary: Update item
                description: Update item information (full update)
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                parameters:
                  - name: id
                    in: path
                    required: true
                    schema:
                      type: string
                      format: uuid
                requestBody:
                  required: true
                  content:
                    application/json:
                      schema:
                        $ref: '#/components/schemas/UpdateSERVICE_NAME_CAMEL_PLACEHOLDERRequest'
                responses:
                  '200':
                    description: Item updated successfully
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/SERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  '400':
                    $ref: '#/components/responses/BadRequest'
                  '404':
                    $ref: '#/components/responses/NotFound'
              delete:
                summary: Delete item
                description: Delete an item
                tags:
                  - SERVICE_NAME_CAMEL_PLACEHOLDER
                parameters:
                  - name: id
                    in: path
                    required: true
                    schema:
                      type: string
                      format: uuid
                responses:
                  '204':
                    description: Item deleted successfully
                  '404':
                    $ref: '#/components/responses/NotFound'
                  '401':
                    $ref: '#/components/responses/Unauthorized'

          components:
            securitySchemes:
              BearerAuth:
                type: http
                scheme: bearer
                bearerFormat: JWT
            
            schemas:
              HealthResponse:
                type: object
                properties:
                  status:
                    type: string
                    example: "UP"
                  service:
                    type: string
                    example: "SERVICE_NAME_PLACEHOLDER"
                  timestamp:
                    type: string
                    format: date-time
                  version:
                    type: string
                    example: "1.0.0"
                required:
                  - status
                  - service
                  - timestamp
              
              SERVICE_NAME_CAMEL_PLACEHOLDERResponse:
                type: object
                properties:
                  id:
                    type: string
                    format: uuid
                    example: "550e8400-e29b-41d4-a716-446655440000"
                  name:
                    type: string
                    example: "Sample Item"
                  description:
                    type: string
                    example: "A sample item description"
                  status:
                    type: string
                    enum: [ACTIVE, INACTIVE, PENDING]
                    example: "ACTIVE"
                  createdAt:
                    type: string
                    format: date-time
                    example: "2024-01-15T10:30:00Z"
                  updatedAt:
                    type: string
                    format: date-time
                    example: "2024-01-20T14:22:00Z"
                required:
                  - id
                  - name
                  - status
                  - createdAt
              
              CreateSERVICE_NAME_CAMEL_PLACEHOLDERRequest:
                type: object
                properties:
                  name:
                    type: string
                    minLength: 1
                    maxLength: 100
                    example: "New Item"
                  description:
                    type: string
                    maxLength: 500
                    example: "Description of the new item"
                required:
                  - name
              
              UpdateSERVICE_NAME_CAMEL_PLACEHOLDERRequest:
                type: object
                properties:
                  name:
                    type: string
                    minLength: 1
                    maxLength: 100
                  description:
                    type: string
                    maxLength: 500
                  status:
                    type: string
                    enum: [ACTIVE, INACTIVE, PENDING]
              
              PagedSERVICE_NAME_CAMEL_PLACEHOLDERResponse:
                type: object
                properties:
                  content:
                    type: array
                    items:
                      $ref: '#/components/schemas/SERVICE_NAME_CAMEL_PLACEHOLDERResponse'
                  totalElements:
                    type: integer
                    format: int64
                    example: 150
                  totalPages:
                    type: integer
                    example: 8
                  size:
                    type: integer
                    example: 20
                  number:
                    type: integer
                    example: 0
                  first:
                    type: boolean
                    example: true
                  last:
                    type: boolean
                    example: false
                required:
                  - content
                  - totalElements
                  - totalPages
                  - size
                  - number
                  - first
                  - last
              
              ErrorResponse:
                type: object
                properties:
                  timestamp:
                    type: string
                    format: date-time
                    example: "2024-01-20T15:30:45Z"
                  status:
                    type: integer
                    example: 400
                  error:
                    type: string
                    example: "Bad Request"
                  message:
                    type: string
                    example: "Validation failed"
                  path:
                    type: string
                    example: "/api/v1/items"
                required:
                  - timestamp
                  - status
                  - error
                  - message
                  - path
            
            responses:
              BadRequest:
                description: Bad request - validation errors
                content:
                  application/json:
                    schema:
                      $ref: '#/components/schemas/ErrorResponse'
              
              Unauthorized:
                description: Authentication required
                content:
                  application/json:
                    schema:
                      $ref: '#/components/schemas/ErrorResponse'
              
              NotFound:
                description: Resource not found
                content:
                  application/json:
                    schema:
                      $ref: '#/components/schemas/ErrorResponse'

          tags:
            - name: SERVICE_NAME_CAMEL_PLACEHOLDER
              description: Item management operations
            - name: Health
              description: Service health endpoints
          SPEC_EOF

            # Replace placeholders in the spec
            sed -i "s/SERVICE_NAME_PLACEHOLDER/${SERVICE_NAME}/g" api-spec.yaml
            sed -i "s/SERVICE_NAME_CAMEL_PLACEHOLDER/${SERVICE_NAME_CAMEL}/g" api-spec.yaml
            sed -i "s/SERVICE_DESCRIPTION_PLACEHOLDER/${{ inputs.description }}/g" api-spec.yaml
            sed -i "s/SERVICE_NAME_PLACEHOLDER_PLURAL/${SERVICE_NAME}s/g" api-spec.yaml
            
            echo "✅ Generated template OpenAPI spec"
          fi

          # Validate the OpenAPI spec
          echo "📄 Validating OpenAPI specification..."
          if [[ ! -s api-spec.yaml ]]; then
            echo "❌ OpenAPI spec file is empty"
            exit 1
          fi

          # Show first few lines of the spec
          echo "📄 OpenAPI specification preview:"
          head -15 api-spec.yaml
          echo "..."

          # Test if Java is available and working
          echo "☕ Testing Java installation..."
          if ! java -version; then
            echo "❌ Java is not available or not working"
            exit 1
          fi

          # Test if the JAR file is executable
          echo "🧪 Testing OpenAPI Generator..."
          if ! java -jar openapi-generator-cli.jar version; then
            echo "❌ OpenAPI Generator is not working"
            exit 1
          fi

          # Generate Spring Boot application
          echo "🔧 Generating Spring Boot service..."

          PACKAGE_NAME="com.eventplatform.$(echo $SERVICE_NAME | tr '-' '.')"

          java -jar openapi-generator-cli.jar generate \
            -i api-spec.yaml \
            -g spring \
            -o . \
            --additional-properties=\
          packageName=${PACKAGE_NAME},\
          apiPackage=${PACKAGE_NAME}.controller,\
          modelPackage=${PACKAGE_NAME}.model,\
          configPackage=${PACKAGE_NAME}.config,\
          basePackage=${PACKAGE_NAME},\
          groupId=com.eventplatform,\
          artifactId=$SERVICE_NAME,\
          artifactVersion=1.0.0,\
          java8=false,\
          dateLibrary=java8,\
          interfaceOnly=false,\
          skipDefaultInterface=false,\
          useTags=true,\
          singleContentTypes=true,\
          performBeanValidation=true,\
          useBeanValidation=true,\
          library=spring-boot,\
          documentationProvider=springdoc,\
          openApiNullable=false,\
          hideGenerationTimestamp=true

          # Check if generation was successful
          if [[ ! -f "pom.xml" ]]; then
            echo "❌ Spring Boot generation failed - no pom.xml found"
            ls -la
            exit 1
          fi

          echo "✅ Spring Boot service generated successfully!"
          echo "📁 Generated files:"
          find . -name "*.java" -type f | head -10
          echo "..."

      - name: Enhance generated service with microservice features
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Check if we have a pom.xml and enhance it
          if [[ -f "pom.xml" ]]; then
            echo "📦 Enhancing pom.xml with additional dependencies..."
            
            # Create a backup
            cp pom.xml pom.xml.backup
            
            # Function to check if dependency exists
            check_dependency() {
              local groupId=$1
              local artifactId=$2
              grep -q "<groupId>$groupId</groupId>" pom.xml && \
              grep -A1 "<groupId>$groupId</groupId>" pom.xml | grep -q "<artifactId>$artifactId</artifactId>"
            }
            
            # Build list of dependencies to add (only if they don't exist)
            DEPS_TO_ADD=""
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-data-jpa"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-data-jpa</artifactId>
          		</dependency>"
            else
              echo "spring-boot-starter-data-jpa already exists"
            fi
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-actuator"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-actuator</artifactId>
          		</dependency>"
            else
              echo "spring-boot-starter-actuator already exists"
            fi
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-validation"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-validation</artifactId>
          		</dependency>"
            else
              echo "spring-boot-starter-validation already exists"
            fi
            
            if ! check_dependency "org.postgresql" "postgresql"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.postgresql</groupId>
          			<artifactId>postgresql</artifactId>
          			<scope>runtime</scope>
          		</dependency>"
            else
              echo "postgresql already exists"
            fi
            
            if ! check_dependency "io.micrometer" "micrometer-registry-prometheus"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>io.micrometer</groupId>
          			<artifactId>micrometer-registry-prometheus</artifactId>
          		</dependency>"
            else
              echo "micrometer-registry-prometheus already exists"
            fi
            
            if ! check_dependency "org.springframework.boot" "spring-boot-starter-test"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.springframework.boot</groupId>
          			<artifactId>spring-boot-starter-test</artifactId>
          			<scope>test</scope>
          		</dependency>"
            else
              echo "spring-boot-starter-test already exists"
            fi
            
            if ! check_dependency "org.flywaydb" "flyway-core"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.flywaydb</groupId>
          			<artifactId>flyway-core</artifactId>
          		</dependency>"
            else
              echo "flyway-core already exists"
            fi
            
            if ! check_dependency "org.flywaydb" "flyway-database-postgresql"; then
              DEPS_TO_ADD="$DEPS_TO_ADD
          		<dependency>
          			<groupId>org.flywaydb</groupId>
          			<artifactId>flyway-database-postgresql</artifactId>
          		</dependency>"
            else
              echo "flyway-database-postgresql already exists"
            fi
            
            # Add dependencies if any were collected
            if [[ -n "$DEPS_TO_ADD" ]]; then
              echo "Adding new dependencies..."
              # Create temp file with additional dependencies
              cat > additional_deps.txt << EOF
          		<!-- Additional Spring Boot Dependencies -->$DEPS_TO_ADD
          EOF
              
              # Insert before </dependencies>
              sed -i '/<\/dependencies>/e cat additional_deps.txt' pom.xml
              rm additional_deps.txt
            else
              echo "All required dependencies already exist"
            fi
            
            # Check if Spring Boot Maven plugin already exists, if not add it
            if ! grep -q "spring-boot-maven-plugin" pom.xml; then
              echo "Adding Spring Boot Maven plugin..."
              # Only add build section if it doesn't exist
              if ! grep -q "<build>" pom.xml; then
                sed -i '/<\/project>/i\
          	<build>\
          		<plugins>\
          			<plugin>\
          				<groupId>org.springframework.boot</groupId>\
          				<artifactId>spring-boot-maven-plugin</artifactId>\
          				<configuration>\
          					<excludes>\
          						<exclude>\
          							<groupId>org.projectlombok</groupId>\
          							<artifactId>lombok</artifactId>\
          						</exclude>\
          					</excludes>\
          				</configuration>\
          			</plugin>\
          		</plugins>\
          	</build>' pom.xml
              else
                # Build section exists, just add the plugin to existing plugins section
                if grep -q "<plugins>" pom.xml; then
                  sed -i '/<\/plugins>/i\
          			<plugin>\
          				<groupId>org.springframework.boot</groupId>\
          				<artifactId>spring-boot-maven-plugin</artifactId>\
          				<configuration>\
          					<excludes>\
          						<exclude>\
          							<groupId>org.projectlombok</groupId>\
          							<artifactId>lombok</artifactId>\
          						</exclude>\
          					</excludes>\
          				</configuration>\
          			</plugin>' pom.xml
                else
                  # Build exists but no plugins section
                  sed -i '/<\/build>/i\
          		<plugins>\
          			<plugin>\
          				<groupId>org.springframework.boot</groupId>\
          				<artifactId>spring-boot-maven-plugin</artifactId>\
          				<configuration>\
          					<excludes>\
          						<exclude>\
          							<groupId>org.projectlombok</groupId>\
          							<artifactId>lombok</artifactId>\
          						</exclude>\
          					</excludes>\
          				</configuration>\
          			</plugin>\
          		</plugins>' pom.xml
                fi
              fi
            else
              echo "Spring Boot Maven plugin already exists, skipping..."
            fi
            
            echo "✅ Enhanced pom.xml successfully"
            echo "📄 Final pom.xml validation:"
            if mvn help:effective-pom -q > /dev/null 2>&1; then
              echo "✅ pom.xml is valid"
            else
              echo "❌ pom.xml has issues, showing structure:"
              grep -n "groupId\|artifactId\|version" pom.xml | head -30
            fi
          else
            echo "❌ No pom.xml found to enhance"
          fi

      - name: Create main application class
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Find the main application class and ensure it exists and is correct
          PACKAGE_DIR="src/main/java/com/eventplatform/$(echo $SERVICE_NAME | tr '-' '/')"
          MAIN_CLASS_NAME="$(echo $SERVICE_NAME | sed 's/-//g' | sed 's/\b\w/\U&/g')Application"
          
          echo "📝 Creating/updating main application class: $MAIN_CLASS_NAME"
          
          # Create the main application class
          mkdir -p "$PACKAGE_DIR"
          cat > "$PACKAGE_DIR/${MAIN_CLASS_NAME}.java" << EOF
          package com.eventplatform.$(echo $SERVICE_NAME | tr '-' '.');
          
          import org.springframework.boot.SpringApplication;
          import org.springframework.boot.autoconfigure.SpringBootApplication;
          import org.springframework.web.bind.annotation.GetMapping;
          import org.springframework.web.bind.annotation.RestController;
          import java.util.Map;
          import java.util.HashMap;
          
          @SpringBootApplication
          public class ${MAIN_CLASS_NAME} {
              public static void main(String[] args) {
                  SpringApplication.run(${MAIN_CLASS_NAME}.class, args);
              }
          }
          
          @RestController
          class HealthController {
              
              @GetMapping("/")
              public Map<String, Object> root() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("service", "$SERVICE_NAME");
                  response.put("status", "UP");
                  response.put("message", "Welcome to $SERVICE_NAME API");
                  response.put("documentation", "/swagger-ui.html");
                  response.put("health", "/actuator/health");
                  return response;
              }
              
              @GetMapping("/api/v1/health")
              public Map<String, Object> health() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("status", "UP");
                  response.put("service", "$SERVICE_NAME");
                  response.put("timestamp", java.time.Instant.now().toString());
                  response.put("version", "1.0.0");
                  return response;
              }
          }
          EOF

      - name: Create application configuration files
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create application.yml with proper configuration
          mkdir -p src/main/resources
          cat > src/main/resources/application.yml << 'EOF'
          server:
            port: ${PORT:8080}
          
          spring:
            application:
              name: SERVICE_NAME_PLACEHOLDER
            datasource:
              url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:SERVICE_NAME_DB_PLACEHOLDER}
              username: ${DB_USERNAME:postgres}
              password: ${DB_PASSWORD:password}
            jpa:
              hibernate:
                ddl-auto: ${JPA_DDL_AUTO:create-drop}
              show-sql: ${JPA_SHOW_SQL:false}
              properties:
                hibernate:
                  format_sql: true
                  dialect: org.hibernate.dialect.PostgreSQLDialect
            
          management:
            endpoints:
              web:
                exposure:
                  include: health,info,metrics,prometheus
            endpoint:
              health:
                show-details: always
            metrics:
              export:
                prometheus:
                  enabled: true
          
          logging:
            level:
              com.eventplatform: ${LOG_LEVEL:INFO}
              org.springframework.web: ${WEB_LOG_LEVEL:WARN}
              org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}
          
          springdoc:
            api-docs:
              path: /api-docs
            swagger-ui:
              path: /swagger-ui.html
              operations-sorter: method
          EOF
          
          # Replace placeholders in application.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" src/main/resources/application.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" src/main/resources/application.yml
          
          # Create application.properties as fallback
          cat > src/main/resources/application.properties << EOF
          # Application Configuration
          spring.application.name=$SERVICE_NAME
          server.port=8080
          
          # Database Configuration
          spring.datasource.url=jdbc:postgresql://localhost:5432/${SERVICE_NAME//-/_}_db
          spring.datasource.username=postgres
          spring.datasource.password=password
          spring.jpa.hibernate.ddl-auto=create-drop
          spring.jpa.show-sql=false
          
          # Actuator Configuration
          management.endpoints.web.exposure.include=health,info,metrics
          management.endpoint.health.show-details=always
          
          # Logging Configuration
          logging.level.com.eventplatform=INFO
          EOF

      - name: Build Spring Boot application
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          echo "🔧 Building the Spring Boot application..."
          
          # Build the application
          if command -v mvn &> /dev/null; then
            echo "📦 Building with Maven..."
            mvn clean package -DskipTests -q
            
            # Check if JAR was created
            if [[ -f target/*.jar ]]; then
              echo "✅ JAR built successfully:"
              ls -la target/*.jar
            else
              echo "❌ JAR build failed, creating minimal JAR structure..."
              mkdir -p target
              # We'll handle this in the Docker build
            fi
          else
            echo "⚠️  Maven not available, will build in Docker"
          fi

      - name: Create Docker configuration
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create an enhanced Dockerfile with multi-stage build
          cat > Dockerfile << 'EOF'
          # Multi-stage build for Spring Boot application
          FROM maven:3.9-openjdk-17-slim AS builder
          
          WORKDIR /app
          
          # Copy pom.xml first for better caching
          COPY pom.xml .
          
          # Download dependencies
          RUN mvn dependency:go-offline -B
          
          # Copy source code
          COPY src ./src
          
          # Build the application
          RUN mvn clean package -DskipTests -B
          
          # Runtime stage
          FROM openjdk:17-jdk-slim
          
          WORKDIR /app
          
          # Copy the JAR from builder stage
          COPY --from=builder /app/target/*.jar app.jar
          
          # Create non-root user
          RUN addgroup --system spring && adduser --system spring --ingroup spring
          USER spring:spring
          
          # Expose port
          EXPOSE 8080
          
          # Health check
          HEALTHCHECK --interval=30s --timeout=3s --start-period=30s --retries=3 \
              CMD curl -f http://localhost:8080/actuator/health || exit 1
          
          # Run the application
          ENTRYPOINT ["java", "-jar", "app.jar"]
          EOF

      - name: Create Docker Compose configuration
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create docker-compose.yml with working setup
          cat > docker-compose.yml << 'EOF'
          version: '3.8'
          services:
            SERVICE_NAME_PLACEHOLDER:
              build: .
              ports:
                - "${SERVICE_PORT:-8080}:8080"
              environment:
                - SPRING_PROFILES_ACTIVE=docker
                - DB_HOST=postgres
                - DB_USERNAME=postgres
                - DB_PASSWORD=password
                - DB_NAME=SERVICE_NAME_DB_PLACEHOLDER
              depends_on:
                postgres:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
            
            postgres:
              image: postgres:15-alpine
              environment:
                - POSTGRES_DB=SERVICE_NAME_DB_PLACEHOLDER
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=password
              ports:
                - "${DB_PORT:-5432}:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5
          
          volumes:
            postgres_data:
          EOF
          
          # Replace placeholders in docker-compose.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" docker-compose.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" docker-compose.yml

      - name: Create utility scripts
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create a startup script
          cat > start.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "🚀 Starting SERVICE_NAME_PLACEHOLDER..."
          
          # Check if Docker is available
          if command -v docker &> /dev/null; then
              echo "🐳 Starting with Docker Compose..."
              docker-compose up --build -d
              
              echo "⏳ Waiting for services to be healthy..."
              sleep 30
              
              echo "🔍 Checking service health..."
              curl -f http://localhost:8080/actuator/health || echo "❌ Health check failed"
              
              echo "📖 API Documentation: http://localhost:8080/swagger-ui.html"
              echo "❤️  Health Endpoint: http://localhost:8080/actuator/health"
              echo "🏠 Service Root: http://localhost:8080/"
          else
              echo "📦 Building with Maven..."
              mvn clean package -DskipTests
              
              echo "☕ Starting Spring Boot application..."
              java -jar target/*.jar
          fi
          EOF
          
          # Replace placeholder in start.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" start.sh
          chmod +x start.sh
          
          # Create a test script
          cat > test-service.sh << 'EOF'
          #!/bin/bash
          set -e
          
          SERVICE_URL="http://localhost:8080"
          
          echo "🧪 Testing SERVICE_NAME_PLACEHOLDER..."
          
          # Test root endpoint
          echo "Testing root endpoint..."
          curl -s "$SERVICE_URL/" | jq . || echo "Root endpoint test failed"
          
          # Test health endpoint
          echo "Testing health endpoint..."
          curl -s "$SERVICE_URL/actuator/health" | jq . || echo "Health endpoint test failed"
          
          # Test API health endpoint
          echo "Testing API health endpoint..."
          curl -s "$SERVICE_URL/api/v1/health" | jq . || echo "API health endpoint test failed"
          
          echo "✅ Service tests completed!"
          EOF
          
          # Replace placeholder in test-service.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" test-service.sh
          chmod +x test-service.sh

      - name: Setup Python for database schema generation
        run: |
          # Install Python3 and PyYAML if not available
          if ! command -v python3 &> /dev/null; then
            echo "Installing Python3..."
            sudo apt-get update && sudo apt-get install -y python3 python3-pip
          fi
          
          if ! python3 -c "import yaml" 2>/dev/null; then
            echo "Installing PyYAML..."
            pip3 install PyYAML
          fi

      - name: Create database schema generation script
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create database directory
          mkdir -p src/main/resources/db/migration
          mkdir -p database/scripts
          
          # Create the Python script for schema generation
          cat > generate_schema.py << 'EOF'
          import yaml
          import json
          import re
          import os
          from datetime import datetime
          
          def openapi_type_to_postgres(openapi_type, format_type=None, enum_values=None):
              """Convert OpenAPI types to PostgreSQL types"""
              type_mapping = {
                  'string': {
                      'date': 'DATE',
                      'date-time': 'TIMESTAMP WITH TIME ZONE',
                      'uuid': 'UUID',
                      'uri': 'TEXT',
                      'url': 'TEXT',
                      'email': 'VARCHAR(255)',
                      'password': 'VARCHAR(255)',
                      None: 'TEXT'
                  },
                  'integer': {
                      'int32': 'INTEGER',
                      'int64': 'BIGINT',
                      None: 'INTEGER'
                  },
                  'number': {
                      'float': 'REAL',
                      'double': 'DOUBLE PRECISION',
                      'decimal': 'DECIMAL(10,2)',
                      None: 'DECIMAL(10,2)'
                  },
                  'boolean': {
                      None: 'BOOLEAN'
                  },
                  'array': {
                      None: 'JSONB'
                  },
                  'object': {
                      None: 'JSONB'
                  }
              }
              
              if enum_values:
                  return f"VARCHAR(50) CHECK (VALUE IN ({', '.join([f\"'{v}'\" for v in enum_values])}))"
              
              return type_mapping.get(openapi_type, {}).get(format_type, type_mapping.get(openapi_type, {}).get(None, 'TEXT'))
          
          def snake_case(name):
              """Convert camelCase or PascalCase to snake_case"""
              s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
              return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
          
          def generate_table_name(schema_name):
              """Generate table name from schema name"""
              table_name = schema_name
              for suffix in ['Response', 'Request', 'DTO', 'Entity']:
                  if table_name.endswith(suffix):
                      table_name = table_name[:-len(suffix)]
                      break
              return snake_case(table_name) + 's'
          
          try:
              # Load the OpenAPI spec
              with open('api-spec.yaml', 'r') as f:
                  spec = yaml.safe_load(f)
              
              schemas = spec.get('components', {}).get('schemas', {})
              
              # Generate SQL
              sql_statements = []
              sql_statements.append("-- Generated PostgreSQL schema from OpenAPI specification")
              sql_statements.append(f"-- Generated on: {datetime.now().isoformat()}")
              sql_statements.append("")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"pg_trgm\";")
              sql_statements.append("")
              
              # Generate tables for schemas
              for schema_name, schema_def in schemas.items():
                  if schema_def.get('type') == 'object' and 'properties' in schema_def:
                      if any(suffix in schema_name for suffix in ['Request', 'Response', 'Error', 'Paged']):
                          continue
                      
                      table_name = generate_table_name(schema_name)
                      sql_statements.append(f"CREATE TABLE IF NOT EXISTS {table_name} (")
                      sql_statements.append("    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),")
                      sql_statements.append("    name VARCHAR(255) NOT NULL,")
                      sql_statements.append("    description TEXT,")
                      sql_statements.append("    status VARCHAR(50) DEFAULT 'ACTIVE',")
                      sql_statements.append("    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    version BIGINT DEFAULT 1")
                      sql_statements.append(");")
                      sql_statements.append("")
              
              # Write files
              schema_content = '\n'.join(sql_statements)
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              print("✅ Generated PostgreSQL schema successfully!")
              
          except Exception as e:
              print(f"⚠️  Could not generate database schema: {e}")
              # Create basic schema as fallback
              basic_schema = f"""-- Basic schema
          CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
          
          CREATE TABLE IF NOT EXISTS entities (
              id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
              name VARCHAR(255) NOT NULL,
              description TEXT,
              status VARCHAR(50) DEFAULT 'ACTIVE',
              created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              version BIGINT DEFAULT 1
          );"""
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              print("✅ Generated basic database schema as fallback")
          EOF

      - name: Generate database schema
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          echo "🗄️  Generating PostgreSQL database schema..."
          python3 generate_schema.py

      - name: Create database initialization scripts
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create database initialization script
          cat > database/scripts/init-database.sh << 'EOF'
          #!/bin/bash
          set -e
          
          DB_NAME=${1:-"SERVICE_NAME_DB_PLACEHOLDER"}
          DB_USER=${2:-"postgres"}
          DB_PASSWORD=${3:-"password"}
          DB_HOST=${4:-"localhost"}
          DB_PORT=${5:-"5432"}
          
          echo "🗄️  Initializing database: $DB_NAME"
          
          # Wait for PostgreSQL to be ready
          until PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c '\q'; do
            echo "⏳ Waiting for PostgreSQL..."
            sleep 2
          done
          
          # Create database if it doesn't exist
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c "CREATE DATABASE \"$DB_NAME\""
          
          # Run schema script
          echo "📋 Running schema migrations..."
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f 001_initial_schema.sql
          
          echo "✅ Database initialization completed!"
          EOF
          
          # Replace placeholder in init script
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" database/scripts/init-database.sh
          chmod +x database/scripts/init-database.sh
          
          # Create sample data script
          cat > database/scripts/002_sample_data.sql << EOF
          -- Sample data for $SERVICE_NAME
          -- Generated on: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          -- Insert sample data here
          -- Example:
          -- INSERT INTO entities (name, description, status) VALUES 
          --   ('Sample Entity 1', 'This is a sample entity for testing', 'ACTIVE'),
          --   ('Sample Entity 2', 'Another sample entity', 'ACTIVE');
          
          -- You can uncomment and modify the above lines to add sample data
          EOF

      - name: Create database documentation
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"
          
          # Create database documentation
          cat > database/README.md << EOF
          # Database Schema for $SERVICE_NAME
          
          This directory contains the PostgreSQL database schema and related scripts for the $SERVICE_NAME.
          
          ## 📁 Structure
          
          - \`scripts/\` - Database scripts and migrations
            - \`001_initial_schema.sql\` - Initial database schema
            - \`002_sample_data.sql\` - Sample data for development
            - \`init-database.sh\` - Database initialization script
          
          ## 🚀 Quick Start
          
          ### Using Docker Compose (Recommended)
          The database is automatically set up when you run:
          \`\`\`bash
          docker-compose up -d
          \`\`\`
          
          ### Manual Setup
          1. **Start PostgreSQL:**
             \`\`\`bash
             docker run -d --name postgres \\
               -e POSTGRES_DB=${SERVICE_NAME//-/_}_db \\
               -e POSTGRES_USER=postgres \\
               -e POSTGRES_PASSWORD=password \\
               -p 5432:5432 postgres:15
             \`\`\`
          
          2. **Initialize the database:**
             \`\`\`bash
             cd database/scripts
             ./init-database.sh
             \`\`\`
          
          3. **Connect to the database:**
             \`\`\`bash
             psql -h localhost -U postgres -d ${SERVICE_NAME//-/_}_db
             \`\`\`
          
          ## 📋 Connection Details
          
          - **Host:** localhost
          - **Port:** 5432
          - **Database:** ${SERVICE_NAME//-/_}_db
          - **Username:** postgres
          - **Password:** password
          EOF
          
          echo "✅ Generated complete PostgreSQL database setup!"
          echo "📁 Database files created:"
          find database -type f | head -10
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create database documentation
          cat > database/README.md << EOF
          # Database Schema for $SERVICE_NAME

          This directory contains the PostgreSQL database schema and related scripts for the $SERVICE_NAME.

          ## 📁 Structure

          - \`scripts/\` - Database scripts and migrations
            - \`001_initial_schema.sql\` - Initial database schema
            - \`002_sample_data.sql\` - Sample data for development
            - \`init-database.sh\` - Database initialization script

          ## 🚀 Quick Start

          ### Using Docker Compose (Recommended)
          The database is automatically set up when you run:
          \`\`\`bash
          docker-compose up -d
          \`\`\`

          ### Manual Setup
          1. **Start PostgreSQL:**
             \`\`\`bash
             docker run -d --name postgres \\
               -e POSTGRES_DB=${SERVICE_NAME//-/_}_db \\
               -e POSTGRES_USER=postgres \\
               -e POSTGRES_PASSWORD=password \\
               -p 5432:5432 postgres:15
             \`\`\`

          2. **Initialize the database:**
             \`\`\`bash
             cd database/scripts
             ./init-database.sh
             \`\`\`

          3. **Connect to the database:**
             \`\`\`bash
             psql -h localhost -U postgres -d ${SERVICE_NAME//-/_}_db
             \`\`\`

          ## 📋 Connection Details

          - **Host:** localhost
          - **Port:** 5432
          - **Database:** ${SERVICE_NAME//-/_}_db
          - **Username:** postgres
          - **Password:** password
          EOF

          echo "✅ Generated complete PostgreSQL database setup!"
          echo "📁 Database files created:"
          find database -type f | head -10
      - name: Create main application class
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Find the main application class and ensure it exists and is correct
          PACKAGE_DIR="src/main/java/com/eventplatform/$(echo $SERVICE_NAME | tr '-' '/')"
          MAIN_CLASS_NAME="$(echo $SERVICE_NAME | sed 's/-//g' | sed 's/\b\w/\U&/g')Application"

          echo "📝 Creating/updating main application class: $MAIN_CLASS_NAME"

          # Create the main application class
          mkdir -p "$PACKAGE_DIR"
          cat > "$PACKAGE_DIR/${MAIN_CLASS_NAME}.java" << EOF
          package com.eventplatform.$(echo $SERVICE_NAME | tr '-' '.');

          import org.springframework.boot.SpringApplication;
          import org.springframework.boot.autoconfigure.SpringBootApplication;
          import org.springframework.web.bind.annotation.GetMapping;
          import org.springframework.web.bind.annotation.RestController;
          import java.util.Map;
          import java.util.HashMap;

          @SpringBootApplication
          public class ${MAIN_CLASS_NAME} {
              public static void main(String[] args) {
                  SpringApplication.run(${MAIN_CLASS_NAME}.class, args);
              }
          }

          @RestController
          class HealthController {
              
              @GetMapping("/")
              public Map<String, Object> root() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("service", "$SERVICE_NAME");
                  response.put("status", "UP");
                  response.put("message", "Welcome to $SERVICE_NAME API");
                  response.put("documentation", "/swagger-ui.html");
                  response.put("health", "/actuator/health");
                  return response;
              }
              
              @GetMapping("/api/v1/health")
              public Map<String, Object> health() {
                  Map<String, Object> response = new HashMap<>();
                  response.put("status", "UP");
                  response.put("service", "$SERVICE_NAME");
                  response.put("timestamp", java.time.Instant.now().toString());
                  response.put("version", "1.0.0");
                  return response;
              }
          }
          EOF

      - name: Create application configuration files
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create application.yml with proper configuration
          mkdir -p src/main/resources
          cat > src/main/resources/application.yml << 'EOF'
          server:
            port: ${PORT:8080}

          spring:
            application:
              name: SERVICE_NAME_PLACEHOLDER
            datasource:
              url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:SERVICE_NAME_DB_PLACEHOLDER}
              username: ${DB_USERNAME:postgres}
              password: ${DB_PASSWORD:password}
            jpa:
              hibernate:
                ddl-auto: ${JPA_DDL_AUTO:create-drop}
              show-sql: ${JPA_SHOW_SQL:false}
              properties:
                hibernate:
                  format_sql: true
                  dialect: org.hibernate.dialect.PostgreSQLDialect
            
          management:
            endpoints:
              web:
                exposure:
                  include: health,info,metrics,prometheus
            endpoint:
              health:
                show-details: always
            metrics:
              export:
                prometheus:
                  enabled: true

          logging:
            level:
              com.eventplatform: ${LOG_LEVEL:INFO}
              org.springframework.web: ${WEB_LOG_LEVEL:WARN}
              org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}

          springdoc:
            api-docs:
              path: /api-docs
            swagger-ui:
              path: /swagger-ui.html
              operations-sorter: method
          EOF

          # Replace placeholders in application.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" src/main/resources/application.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" src/main/resources/application.yml

          # Create application.properties as fallback
          cat > src/main/resources/application.properties << EOF
          # Application Configuration
          spring.application.name=$SERVICE_NAME
          server.port=8080

          # Database Configuration
          spring.datasource.url=jdbc:postgresql://localhost:5432/${SERVICE_NAME//-/_}_db
          spring.datasource.username=postgres
          spring.datasource.password=password
          spring.jpa.hibernate.ddl-auto=create-drop
          spring.jpa.show-sql=false

          # Actuator Configuration
          management.endpoints.web.exposure.include=health,info,metrics
          management.endpoint.health.show-details=always

          # Logging Configuration
          logging.level.com.eventplatform=INFO
          EOF

      - name: Build Spring Boot application
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          echo "🔧 Building the Spring Boot application..."

          # Build the application
          if command -v mvn &> /dev/null; then
            echo "📦 Building with Maven..."
            mvn clean package -DskipTests -q
            
            # Check if JAR was created
            if [[ -f target/*.jar ]]; then
              echo "✅ JAR built successfully:"
              ls -la target/*.jar
            else
              echo "❌ JAR build failed, creating minimal JAR structure..."
              mkdir -p target
              # We'll handle this in the Docker build
            fi
          else
            echo "⚠️  Maven not available, will build in Docker"
          fi

      - name: Create Docker configuration
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create an enhanced Dockerfile with multi-stage build
          cat > Dockerfile << 'EOF'
          # Multi-stage build for Spring Boot application
          FROM maven:3.9-openjdk-17-slim AS builder

          WORKDIR /app

          # Copy pom.xml first for better caching
          COPY pom.xml .

          # Download dependencies
          RUN mvn dependency:go-offline -B

          # Copy source code
          COPY src ./src

          # Build the application
          RUN mvn clean package -DskipTests -B

          # Runtime stage
          FROM openjdk:17-jdk-slim

          WORKDIR /app

          # Copy the JAR from builder stage
          COPY --from=builder /app/target/*.jar app.jar

          # Create non-root user
          RUN addgroup --system spring && adduser --system spring --ingroup spring
          USER spring:spring

          # Expose port
          EXPOSE 8080

          # Health check
          HEALTHCHECK --interval=30s --timeout=3s --start-period=30s --retries=3 \
              CMD curl -f http://localhost:8080/actuator/health || exit 1

          # Run the application
          ENTRYPOINT ["java", "-jar", "app.jar"]
          EOF

      - name: Create Docker Compose configuration
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create docker-compose.yml with working setup
          cat > docker-compose.yml << 'EOF'
          version: '3.8'
          services:
            SERVICE_NAME_PLACEHOLDER:
              build: .
              ports:
                - "${SERVICE_PORT:-8080}:8080"
              environment:
                - SPRING_PROFILES_ACTIVE=docker
                - DB_HOST=postgres
                - DB_USERNAME=postgres
                - DB_PASSWORD=password
                - DB_NAME=SERVICE_NAME_DB_PLACEHOLDER
              depends_on:
                postgres:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
            
            postgres:
              image: postgres:15-alpine
              environment:
                - POSTGRES_DB=SERVICE_NAME_DB_PLACEHOLDER
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=password
              ports:
                - "${DB_PORT:-5432}:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5

          volumes:
            postgres_data:
          EOF

          # Replace placeholders in docker-compose.yml
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" docker-compose.yml
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" docker-compose.yml

      - name: Create utility scripts
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create a startup script
          cat > start.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "🚀 Starting SERVICE_NAME_PLACEHOLDER..."

          # Check if Docker is available
          if command -v docker &> /dev/null; then
              echo "🐳 Starting with Docker Compose..."
              docker-compose up --build -d
              
              echo "⏳ Waiting for services to be healthy..."
              sleep 30
              
              echo "🔍 Checking service health..."
              curl -f http://localhost:8080/actuator/health || echo "❌ Health check failed"
              
              echo "📖 API Documentation: http://localhost:8080/swagger-ui.html"
              echo "❤️  Health Endpoint: http://localhost:8080/actuator/health"
              echo "🏠 Service Root: http://localhost:8080/"
          else
              echo "📦 Building with Maven..."
              mvn clean package -DskipTests
              
              echo "☕ Starting Spring Boot application..."
              java -jar target/*.jar
          fi
          EOF

          # Replace placeholder in start.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" start.sh
          chmod +x start.sh

          # Create a test script
          cat > test-service.sh << 'EOF'
          #!/bin/bash
          set -e

          SERVICE_URL="http://localhost:8080"

          echo "🧪 Testing SERVICE_NAME_PLACEHOLDER..."

          # Test root endpoint
          echo "Testing root endpoint..."
          curl -s "$SERVICE_URL/" | jq . || echo "Root endpoint test failed"

          # Test health endpoint
          echo "Testing health endpoint..."
          curl -s "$SERVICE_URL/actuator/health" | jq . || echo "Health endpoint test failed"

          # Test API health endpoint
          echo "Testing API health endpoint..."
          curl -s "$SERVICE_URL/api/v1/health" | jq . || echo "API health endpoint test failed"

          echo "✅ Service tests completed!"
          EOF

          # Replace placeholder in test-service.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/$SERVICE_NAME/g" test-service.sh
          chmod +x test-service.sh

      - name: Setup Python for database schema generation
        run: |
          # Install Python3 and PyYAML if not available
          if ! command -v python3 &> /dev/null; then
            echo "Installing Python3..."
            sudo apt-get update && sudo apt-get install -y python3 python3-pip
          fi

          if ! python3 -c "import yaml" 2>/dev/null; then
            echo "Installing PyYAML..."
            pip3 install PyYAML
          fi

      - name: Create database schema generation script
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create database directory
          mkdir -p src/main/resources/db/migration
          mkdir -p database/scripts

          # Create the Python script for schema generation
          cat > generate_schema.py << 'EOF'
          import yaml
          import json
          import re
          import os
          from datetime import datetime

          def openapi_type_to_postgres(openapi_type, format_type=None, enum_values=None):
              """Convert OpenAPI types to PostgreSQL types"""
              type_mapping = {
                  'string': {
                      'date': 'DATE',
                      'date-time': 'TIMESTAMP WITH TIME ZONE',
                      'uuid': 'UUID',
                      'uri': 'TEXT',
                      'url': 'TEXT',
                      'email': 'VARCHAR(255)',
                      'password': 'VARCHAR(255)',
                      None: 'TEXT'
                  },
                  'integer': {
                      'int32': 'INTEGER',
                      'int64': 'BIGINT',
                      None: 'INTEGER'
                  },
                  'number': {
                      'float': 'REAL',
                      'double': 'DOUBLE PRECISION',
                      'decimal': 'DECIMAL(10,2)',
                      None: 'DECIMAL(10,2)'
                  },
                  'boolean': {
                      None: 'BOOLEAN'
                  },
                  'array': {
                      None: 'JSONB'
                  },
                  'object': {
                      None: 'JSONB'
                  }
              }
              
              if enum_values:
                  return f"VARCHAR(50) CHECK (VALUE IN ({', '.join([f\"'{v}'\" for v in enum_values])}))"
              
              return type_mapping.get(openapi_type, {}).get(format_type, type_mapping.get(openapi_type, {}).get(None, 'TEXT'))

          def snake_case(name):
              """Convert camelCase or PascalCase to snake_case"""
              s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
              return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

          def generate_table_name(schema_name):
              """Generate table name from schema name"""
              table_name = schema_name
              for suffix in ['Response', 'Request', 'DTO', 'Entity']:
                  if table_name.endswith(suffix):
                      table_name = table_name[:-len(suffix)]
                      break
              return snake_case(table_name) + 's'

          try:
              # Load the OpenAPI spec
              with open('api-spec.yaml', 'r') as f:
                  spec = yaml.safe_load(f)
              
              schemas = spec.get('components', {}).get('schemas', {})
              
              # Generate SQL
              sql_statements = []
              sql_statements.append("-- Generated PostgreSQL schema from OpenAPI specification")
              sql_statements.append(f"-- Generated on: {datetime.now().isoformat()}")
              sql_statements.append("")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";")
              sql_statements.append("CREATE EXTENSION IF NOT EXISTS \"pg_trgm\";")
              sql_statements.append("")
              
              # Generate tables for schemas
              for schema_name, schema_def in schemas.items():
                  if schema_def.get('type') == 'object' and 'properties' in schema_def:
                      if any(suffix in schema_name for suffix in ['Request', 'Response', 'Error', 'Paged']):
                          continue
                      
                      table_name = generate_table_name(schema_name)
                      sql_statements.append(f"CREATE TABLE IF NOT EXISTS {table_name} (")
                      sql_statements.append("    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),")
                      sql_statements.append("    name VARCHAR(255) NOT NULL,")
                      sql_statements.append("    description TEXT,")
                      sql_statements.append("    status VARCHAR(50) DEFAULT 'ACTIVE',")
                      sql_statements.append("    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,")
                      sql_statements.append("    version BIGINT DEFAULT 1")
                      sql_statements.append(");")
                      sql_statements.append("")
              
              # Write files
              schema_content = '\n'.join(sql_statements)
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(schema_content)
              
              print("✅ Generated PostgreSQL schema successfully!")
              
          except Exception as e:
              print(f"⚠️  Could not generate database schema: {e}")
              # Create basic schema as fallback
              basic_schema = f"""-- Basic schema
          CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

          CREATE TABLE IF NOT EXISTS entities (
              id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
              name VARCHAR(255) NOT NULL,
              description TEXT,
              status VARCHAR(50) DEFAULT 'ACTIVE',
              created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
              version BIGINT DEFAULT 1
          );"""
              
              with open('database/scripts/001_initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              with open('src/main/resources/db/migration/V1__Initial_schema.sql', 'w') as f:
                  f.write(basic_schema)
              
              print("✅ Generated basic database schema as fallback")
          EOF

      - name: Generate database schema
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          echo "🗄️  Generating PostgreSQL database schema..."
          python3 generate_schema.py

      - name: Create database initialization scripts
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Add Flyway dependency to pom.xml for database migrations
          if [[ -f "pom.xml" ]]; then
            echo "📦 Adding Flyway for database migrations..."
            sed -i '/<\/dependencies>/i\
          		<dependency>\
          			<groupId>org.flywaydb</groupId>\
          			<artifactId>flyway-core</artifactId>\
          		</dependency>\
          		<dependency>\
          			<groupId>org.flywaydb</groupId>\
          			<artifactId>flyway-database-postgresql</artifactId>\
          		</dependency>' pom.xml
          fi

          # Create database initialization script
          cat > database/scripts/init-database.sh << 'EOF'
          #!/bin/bash
          set -e

          DB_NAME=${1:-"SERVICE_NAME_DB_PLACEHOLDER"}
          DB_USER=${2:-"postgres"}
          DB_PASSWORD=${3:-"password"}
          DB_HOST=${4:-"localhost"}
          DB_PORT=${5:-"5432"}

          echo "🗄️  Initializing database: $DB_NAME"

          # Wait for PostgreSQL to be ready
          until PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c '\q'; do
            echo "⏳ Waiting for PostgreSQL..."
            sleep 2
          done

          # Create database if it doesn't exist
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -c "CREATE DATABASE \"$DB_NAME\""

          # Run schema script
          echo "📋 Running schema migrations..."
          PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f 001_initial_schema.sql

          echo "✅ Database initialization completed!"
          EOF

          # Replace placeholder in init script
          sed -i "s/SERVICE_NAME_DB_PLACEHOLDER/${SERVICE_NAME//-/_}_db/g" database/scripts/init-database.sh
          chmod +x database/scripts/init-database.sh

          # Create sample data script
          cat > database/scripts/002_sample_data.sql << EOF
          -- Sample data for $SERVICE_NAME
          -- Generated on: $(date -u +"%Y-%m-%dT%H:%M:%SZ")

          -- Insert sample data here
          -- Example:
          -- INSERT INTO entities (name, description, status) VALUES 
          --   ('Sample Entity 1', 'This is a sample entity for testing', 'ACTIVE'),
          --   ('Sample Entity 2', 'Another sample entity', 'ACTIVE');

          -- You can uncomment and modify the above lines to add sample data
          EOF

      - name: Create database documentation
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          cd "$SERVICE_NAME"

          # Create database documentation
          cat > database/README.md << EOF
          # Database Schema for $SERVICE_NAME

          This directory contains the PostgreSQL database schema and related scripts for the $SERVICE_NAME.

          ## 📁 Structure

          - \`scripts/\` - Database scripts and migrations
            - \`001_initial_schema.sql\` - Initial database schema
            - \`002_sample_data.sql\` - Sample data for development
            - \`init-database.sh\` - Database initialization script

          ## 🚀 Quick Start

          ### Using Docker Compose (Recommended)
          The database is automatically set up when you run:
          \`\`\`bash
          docker-compose up -d
          \`\`\`

          ### Manual Setup
          1. **Start PostgreSQL:**
             \`\`\`bash
             docker run -d --name postgres \\
               -e POSTGRES_DB=${SERVICE_NAME//-/_}_db \\
               -e POSTGRES_USER=postgres \\
               -e POSTGRES_PASSWORD=password \\
               -p 5432:5432 postgres:15
             \`\`\`

          2. **Initialize the database:**
             \`\`\`bash
             cd database/scripts
             ./init-database.sh
             \`\`\`

          3. **Connect to the database:**
             \`\`\`bash
             psql -h localhost -U postgres -d ${SERVICE_NAME//-/_}_db
             \`\`\`

          ## 📋 Connection Details

          - **Host:** localhost
          - **Port:** 5432
          - **Database:** ${SERVICE_NAME//-/_}_db
          - **Username:** postgres
          - **Password:** password
          EOF

          echo "✅ Generated complete PostgreSQL database setup!"
          echo "📁 Database files created:"
          find database -type f | head -10
      - name: Create Port service entity
        if: ${{ inputs.port_run_id != '' }}
        continue-on-error: true
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.getport.io
          operation: UPSERT
          identifier: ${{ inputs.service_name }}
          title: "${{ inputs.service_name }} Service"
          blueprint: "service"
          properties: |
            {
              "description": "${{ inputs.description }}",
              "type": "microservice",
              "language": "java",
              "framework": "spring-boot",
              "port": 8080,
              "health_endpoint": "http://localhost:8080/actuator/health",
              "api_docs": "http://localhost:8080/swagger-ui.html",
              "status": "development",
              "version": "1.0.0",
              "created_by": "${{ github.actor }}",
              "created_at": "${{ github.event.head_commit.timestamp }}"
            }
          relations: |
            {
              "repository": "${{ github.repository }}"
            }

      - name: Create service directory and commit to current repository
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Default token works for current repo
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"

          # Create services directory if it doesn't exist
          mkdir -p services

          # Move generated code to services directory
          mv "$SERVICE_NAME" "services/$SERVICE_NAME"

          # Create README for the services directory
          if [[ ! -f "services/README.md" ]]; then
            cat > services/README.md << 'EOF'
          # Microservices

          This directory contains all the scaffolded microservices for the Event Management Platform.

          ## Services
          EOF
          fi

          # Add service to the README
          echo "- [\`$SERVICE_NAME\`](./services/$SERVICE_NAME) - ${{ inputs.description }}" >> services/README.md

          # Create comprehensive README for the service
          cd "services/$SERVICE_NAME"
          cat > README.md << EOF
          # $SERVICE_NAME

          ${{ inputs.description }}

          Generated Spring Boot microservice from OpenAPI specification.

          ## Quick Start

          1. **Navigate to service directory:**
             \`\`\`bash
             cd services/$SERVICE_NAME
             \`\`\`

          2. **Start with Docker Compose:**
             \`\`\`bash
             docker-compose up -d
             \`\`\`

          3. **Or run locally:**
             \`\`\`bash
             mvn spring-boot:run
             \`\`\`

          4. **Test the API:**
             \`\`\`bash
             curl http://localhost:8080/api/v1/health
             \`\`\`

          5. **View API Documentation:**
             \`\`\`
             http://localhost:8080/swagger-ui.html
             \`\`\`

          ## Generated Features

          ✅ **RESTful API** - Complete CRUD operations  
          ✅ **OpenAPI Documentation** - Interactive Swagger UI  
          ✅ **Data Validation** - Bean validation with error handling  
          ✅ **Pagination** - Built-in pagination support  
          ✅ **Docker Support** - Ready for containerization  
          ✅ **Database Integration** - PostgreSQL with JPA  
          ✅ **Health Checks** - Actuator endpoints  

          ## API Endpoints

          | Method | Endpoint | Description |
          |--------|----------|-------------|
          | GET | \`/api/v1/health\` | Health check |
          | GET | \`/api/v1/${SERVICE_NAME}s\` | List items with pagination |
          | POST | \`/api/v1/${SERVICE_NAME}s\` | Create new item |
          | GET | \`/api/v1/${SERVICE_NAME}s/{id}\` | Get item by ID |
          | PUT | \`/api/v1/${SERVICE_NAME}s/{id}\` | Update item |
          | DELETE | \`/api/v1/${SERVICE_NAME}s/{id}\` | Delete item |

          ## Development

          This service was generated using the Event Management Platform scaffolding system.

          - **Generated by:** ${{ github.actor }}
          - **Generated on:** $(date)
          - **Template:** OpenAPI Generator with Spring Boot

          ## Next Steps

          1. **Implement Business Logic** - Add your service implementation
          2. **Create JPA Entities** - Define your database entities  
          3. **Add Tests** - Write unit and integration tests
          4. **Configure Security** - Set up authentication
          5. **Add Monitoring** - Configure metrics and logging
          EOF

          cd ../..

          # Commit the changes
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          git add services/
          git commit -m "🎉 Add $SERVICE_NAME microservice

          Generated Spring Boot service with:
          ✅ Complete RESTful API from OpenAPI spec
          ✅ CRUD operations with validation
          ✅ Pagination and filtering support  
          ✅ Docker containerization
          ✅ PostgreSQL database integration
          ✅ Interactive API documentation
          ✅ Health monitoring endpoints

          Generated by: ${{ github.actor }}
          Description: ${{ inputs.description }}
          Location: services/$SERVICE_NAME/

          Next: Implement business logic and entities"

          git push origin main

          echo "✅ Service '$SERVICE_NAME' created in services/ directory!"
          echo "📁 Location: services/$SERVICE_NAME/"
          echo "🌐 Repository: https://github.com/${{ github.repository }}"
          echo "📖 API Documentation: http://localhost:8080/swagger-ui.html (after running)"

          - name: Log completion to Port
                    if: ${{ inputs.port_run_id != '' }}
                    continue-on-error: true
                    uses: port-labs/port-github-action@v1
                    with:
                      clientId: ${{ secrets.PORT_CLIENT_ID }}
                      clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
                      baseUrl: https://api.getport.io
                      operation: PATCH_RUN
                      runId: ${{ inputs.port_run_id }}
                      logMessage: "✅ Successfully scaffolded service: ${{ inputs.service_name }}"
